## Содержание

<!-- MarkdownTOC levels="2,3,4" autolink="true" -->

- [Ch 4. JS Basic](#ch-4-js-basic)
    - [4.1 Подключение отладочных возможностей](#41-%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
    - [4.2 Функции](#42-%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
        - [4.2.1 Определение функции через присваивание переменной](#421-%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9)
        - [4.2.2 Простое определение функции](#422-%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
        - [4.2.3 Функция с параметрами по умолчанию](#423-%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D1%81-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B0%D0%BC%D0%B8-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)
        - [4.2.4 Остаточные параметры \(rest parameters\)](#424-%D0%9E%D1%81%D1%82%D0%B0%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-rest-parameters)
        - [4.2.5 Возврат результата](#425-%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82%D0%B0)
        - [4.2.6 Функция как параметр другой функции](#426-%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BA%D0%B0%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B9-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
        - [4.2.7 Лямбда-функции](#427-%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
    - [4.3 Переменные и типы](#43-%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8-%D1%82%D0%B8%D0%BF%D1%8B)
        - [4.3.1 Объявление переменных](#431-%D0%9E%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
        - [4.3.2 Примитивные типы](#432-%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B)
        - [4.3.3 Строки-шаблоны](#433-%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B)
    - [4.4 Операторы](#44-%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B)
    - [4.5 Преобразование типов](#45-%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
    - [4.6 Массивы](#46-%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B)
        - [4.6.1 Основы](#461-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [4.6.2 Spread operator `...`](#462-spread-operator-)
    - [4.7 Объекты](#47-%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B)
    - [4.8 Модули](#48-%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B8)
- [Ch 9. Основы Vue](#ch-9-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-vue)
    - [9.0 Предварительные действия](#90-%D0%9F%D1%80%D0%B5%D0%B4%D0%B2%D0%B0%D1%80%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F)
        - [9.0.1 Использование шаблонов](#901-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2)
        - [9.0.2 Подключение bootstrap](#902-%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-bootstrap)
    - [9.1 Объект Vue](#91-%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82-vue)
        - [9.1.1 Скелет приложения](#911-%D0%A1%D0%BA%D0%B5%D0%BB%D0%B5%D1%82-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)
        - [9.1.2 Добавление данных](#912-%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [9.1.3 Обработчики событий](#913-%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
        - [9.1.4 Вычисляемые переменные](#914-%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5)
    - [9.2 Компоненты](#92-%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
        - [9.2.1 Основы](#921-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [9.2.2 Регистрация и применение](#922-%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
        - [9.2.3 Отделение шаблонов внутри файла](#923-%D0%9E%D1%82%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0)
        - [9.2.4 Разделение файлов шаблона и скрипта](#924-%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0-%D0%B8-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%B0)
- [Ch 11. Data binding](#ch-11-data-binding)
    - [11.1 Структура компонентов](#111-%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
    - [11.2 Отображение данных](#112-%D0%9E%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [11.2.1 Связывание данных: Текстовая интерполяция](#1121-%D0%A1%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)
        - [11.2.2 Выражение в переменных шаблона](#1122-%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0)
    - [11.2.3 Computed свойства](#1123-computed-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0)
    - [11.2.4 Методы](#1124-%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B)
    - [11.2.5 Фильтры](#1125-%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D1%8B)
- [Ch 12. Базовые директривы](#ch-12-%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D1%80%D0%B8%D0%B2%D1%8B)
    - [12.1 Основы](#121-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
    - [12.2 Вывод текста](#122-%D0%92%D1%8B%D0%B2%D0%BE%D0%B4-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0)
    - [12.3 Вывод html](#123-%D0%92%D1%8B%D0%B2%D0%BE%D0%B4-html)
    - [12.4 Условные директивы](#124-%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B)
        - [12.4.1 if](#1241-if)
        - [12.4.2 else и else-if](#1242-else-%D0%B8-else-if)
        - [12.4.3 show](#1243-show)
    - [12.5 Установка атрибутов элемента \(v-bind\)](#125-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B0%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%BE%D0%B2-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0-v-bind)
        - [12.5.1 Установка class](#1251-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-class)
        - [12.5.2 Установка стиля](#1252-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D1%81%D1%82%D0%B8%D0%BB%D1%8F)
        - [12.5.3 Установка пользовательских атрибутов](#1253-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D1%85-%D0%B0%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%BE%D0%B2)
- [Ch 13. Директивы-циклы](#ch-13-%D0%94%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-%D1%86%D0%B8%D0%BA%D0%BB%D1%8B)
    - [13.1 Директива v-for](#131-%D0%94%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%B0-v-for)
        - [13.1.1 Основы](#1311-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [13.1.2 Работа с индексами](#1312-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0%D0%BC%D0%B8)
        - [13.1.2 Расширенная форма \(template\)](#1312-%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D0%B0-template)
        - [13.1.3 Изменения в массивах](#1313-%D0%98%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D1%85)
    - [13.2 Перечисление свойств объекта](#132-%D0%9F%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)
        - [13.2.1 Вывод объекта через v-for](#1321-%D0%92%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-v-for)
        - [13.2.2 Порядок вывода свойств объекта](#1322-%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)
    - [13.3 Циклы без данных](#133-%D0%A6%D0%B8%D0%BA%D0%BB%D1%8B-%D0%B1%D0%B5%D0%B7-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
- [Ch 14. Обработка событий](#ch-14-%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
    - [14.1 Основы](#141-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
    - [14.2 События и объекты событий](#142-%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
    - [14.3 Методы для обработки событий](#143-%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
    - [14.4 Обработка нескольких событий на одном элементе](#144-%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D1%85-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-%D0%BD%D0%B0-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B5)
    - [14.5 Модификаторы событий](#145-%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
        - [14.5.1 Распространение событий](#1451-%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
        - [14.5.2 Модификатор once](#1452-%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-once)
    - [14.6 События мыши](#146-%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F-%D0%BC%D1%8B%D1%88%D0%B8)
    - [14.7 События клавиатуры](#147-%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F-%D0%BA%D0%BB%D0%B0%D0%B2%D0%B8%D0%B0%D1%82%D1%83%D1%80%D1%8B)
- [Ch 15. Работа с элементами форм](#ch-15-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8-%D1%84%D0%BE%D1%80%D0%BC)
    - [15.1 2-way binding](#151-2-way-binding)
    - [15.2 Директива v-model](#152-%D0%94%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%B0-v-model)
    - [15.3 Использование v-model для элементов ввода](#153-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-v-model-%D0%B4%D0%BB%D1%8F-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0)
        - [15.3.1 Текстовые поля](#1531-%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F)
        - [15.3.2 Радиокнопки](#1532-%D0%A0%D0%B0%D0%B4%D0%B8%D0%BE%D0%BA%D0%BD%D0%BE%D0%BF%D0%BA%D0%B8)
        - [15.3.3 Checkboxes](#1533-checkboxes)
        - [15.3.4 Select element](#1534-select-element)
    - [15.4 Модификаторы v-model](#154-%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B-v-model)
        - [15.4.1 number](#1541-number)
        - [15.4.2 lazy](#1542-lazy)
        - [15.4.3 trim](#1543-trim)
    - [15.5 Связывание со сложными типами данных](#155-%D0%A1%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D1%8B%D0%BC%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0%D0%BC%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [15.5.1 Селекторы для массива](#1551-%D0%A1%D0%B5%D0%BB%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
        - [15.5.2 Преобрахование значения Checkbox в другие типы](#1552-%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D1%85%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-checkbox-%D0%B2-%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B)
        - [15.5.3 Пользовательские значения для селекторов и radio buttons](#1553-%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B4%D0%BB%D1%8F-%D1%81%D0%B5%D0%BB%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2-%D0%B8-radio-buttons)
- [Ch 16. Компоненты](#ch-16-%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
    - [16.1 Компоненты как строительные блоки](#161-%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D0%BA%D0%B0%D0%BA-%D1%81%D1%82%D1%80%D0%BE%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8)
        - [16.1.1 Основы](#1611-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [16.1.2 Дочерние компоненты](#1612-%D0%94%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
        - [16.1.3 Имена компонентов и элементов](#1613-%D0%98%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%B8-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
        - [16.1.4 Глобальная регистрация компонентов](#1614-%D0%93%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
    - [16.2 Изоляция и связанность компонентов](#162-%D0%98%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F-%D0%B8-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
        - [16.2.1 Изоляция](#1621-%D0%98%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)
        - [16.2.2 CSS scoping](#1622-css-scoping)
        - [16.2.3 Props компонентов](#1623-props-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
    - [16.3 Передача данных от дочернего компонента родителю](#163-%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BE%D1%82-%D0%B4%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B5%D0%B3%D0%BE-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-%D1%80%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8E)
    - [16.4 Слоты](#164-%D0%A1%D0%BB%D0%BE%D1%82%D1%8B)
        - [16.4.1 Основы](#1641-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [16.4.2 Именнованные слоты](#1642-%D0%98%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%BB%D0%BE%D1%82%D1%8B)
- [Ch 17. Жизненный цикл компонентов](#ch-17-%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D1%86%D0%B8%D0%BA%D0%BB-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
    - [17.0 Основы](#170-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
    - [17.1 Фаза создания](#171-%D0%A4%D0%B0%D0%B7%D0%B0-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)
    - [17.2 Фаза монтирования](#172-%D0%A4%D0%B0%D0%B7%D0%B0-%D0%BC%D0%BE%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
    - [17.3 Фаза обновления](#173-%D0%A4%D0%B0%D0%B7%D0%B0-%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
    - [17.4 Отслеживание изменений через watch](#174-%D0%9E%D1%82%D1%81%D0%BB%D0%B5%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-watch)
        - [17.4.1 Свойство watch](#1741-%D0%A1%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE-watch)
        - [17.4.2 Дополнительные настройки watch](#1742-%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8-watch)
    - [17.5 Фаза разрушения](#175-%D0%A4%D0%B0%D0%B7%D0%B0-%D1%80%D0%B0%D0%B7%D1%80%D1%83%D1%88%D0%B5%D0%BD%D0%B8%D1%8F)
    - [17.6 Обработка ошибок](#176-%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA)
        - [17.6.1 Основы](#1761-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [17.6.2 Глобальный обработчик ошибок](#1762-%D0%93%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA)
- [Ch 18. Слабо связанные компоненты](#ch-18-%D0%A1%D0%BB%D0%B0%D0%B1%D0%BE-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
    - [18.1 Внедрение зависимостей](#181-%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
        - [18.1.0 Основы](#1810-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [18.1.1 Объявление сервиса](#1811-%D0%9E%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%B0)
        - [18.1.2 Подключение сервиса через внедрение зависимостей](#1812-%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%B0-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D0%B2%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
        - [18.1.3 Переопределение сервисов](#1813-%D0%9F%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2)
        - [18.1.4 Реактивные сервисы](#1814-%D0%A0%D0%B5%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B)
        - [18.1.5 Другие свойства сервисов](#1815-%D0%94%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2)
    - [18.2 Event Bus](#182-event-bus)
        - [18.2.1 Создание шины](#1821-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%88%D0%B8%D0%BD%D1%8B)
        - [18.2.2 Отправка событий по шине](#1822-%D0%9E%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-%D0%BF%D0%BE-%D1%88%D0%B8%D0%BD%D0%B5)
        - [18.2.3 Получение событий](#1823-%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
        - [18.2.4 Локальная шина событий](#1824-%D0%9B%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D1%88%D0%B8%D0%BD%D0%B0-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
- [Ch 19. Взаимодействие с RESTFul сервисами](#ch-19-%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D1%81-restful-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%B0%D0%BC%D0%B8)
    - [19.1 Механизмы HTTP запросов](#191-%D0%9C%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%B7%D0%BC%D1%8B-http-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2)
    - [19.2 Cross-origin запросы](#192-cross-origin-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)
    - [19.3 Выполнение запроса](#193-%D0%92%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0)
    - [19.4 Создание отдельного сервиса для запросов](#194-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D1%82%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%B0-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2)
    - [19.5 Различные HTTP операции](#195-%D0%A0%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D0%B5-http-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
    - [19.6 Сервис для обработки ошибок](#196-%D0%A1%D0%B5%D1%80%D0%B2%D0%B8%D1%81-%D0%B4%D0%BB%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA)
- [Ch 20. Data Store \(Vuex\)](#ch-20-data-store-vuex)
    - [20.1 Создание и использование Data Store \(хранилища\)](#201-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-data-store-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0)
        - [20.1.1 Создание](#2011-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5)
        - [20.1.2 State и мутации](#2012-state-%D0%B8-%D0%BC%D1%83%D1%82%D0%B0%D1%86%D0%B8%D0%B8)
        - [20.1.3 Доступ к хранилищу из компонентов](#2013-%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D1%83-%D0%B8%D0%B7-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
        - [20.1.4 Использование хранилища](#2014-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0)
    - [20.2 Вычисляемые свойства в хранилище \(геттеры\)](#202-%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D0%B2-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B5-%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B)
        - [20.2.1 Геттеры](#2021-%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B)
        - [20.2.2 Использование в компонентах](#2022-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D1%85)
        - [20.2.3 Передача аргументов в геттеры](#2023-%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%B2-%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B)
    - [20.3 Асинхронные операции](#203-%D0%90%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
    - [20.4 Подключение watch`еров](#204-%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-watch%D0%B5%D1%80%D0%BE%D0%B2)
    - [20.5 Маппинги](#205-%D0%9C%D0%B0%D0%BF%D0%BF%D0%B8%D0%BD%D0%B3%D0%B8)
    - [20.6 Модули](#206-%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B8)
- [Ch 21. Динамические компоненты](#ch-21-%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
    - [21.1 Жизненный цикл](#211-%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D1%86%D0%B8%D0%BA%D0%BB)
    - [21.2 Динамическое отображение](#212-%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BE%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
        - [21.2.1 Отображение через *is*](#2121-%D0%9E%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-is)
        - [21.2.2 Пример навигации по приложению](#2122-%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%BD%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8E)
- [Ch 22. URL Routing](#ch-22-url-routing)
    - [22.1 Основы](#221-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
        - [22.1.1 Конфигурирование](#2211-%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
        - [22.1.2 Подключение конфигурации](#2212-%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
        - [22.1.3 Отображение компонентов через роутинг](#2213-%D0%9E%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%80%D0%BE%D1%83%D1%82%D0%B8%D0%BD%D0%B3)
        - [22.1.4 Навигация по URL](#2214-%D0%9D%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-url)
        - [22.1.5 Навигация через html-элементы](#2215-%D0%9D%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D1%8F-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-html-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B)
    - [22.2 Url Route Matching](#222-url-route-matching)
        - [22.2.1 Работа через фрагменты](#2221-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D1%8B)
        - [22.2.2 Работа без фрагментов](#2222-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B1%D0%B5%D0%B7-%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
        - [22.2.3 Перехват неверных адресов](#2223-%D0%9F%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82-%D0%BD%D0%B5%D0%B2%D0%B5%D1%80%D0%BD%D1%8B%D1%85-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%BE%D0%B2)
        - [22.2.4 Псевдонимы для адресов](#2224-%D0%9F%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%BE%D0%B2)
        - [22.2.5 Получение данных о url в компонентах](#2225-%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BE-url-%D0%B2-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D1%85)
        - [22.2.6 Динамические пути](#2226-%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B8)
        - [22.2.7 Использование регулярных выражений](#2227-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D1%85-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9)
        - [22.2.8 Именованные пути](#2228-%D0%98%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BF%D1%83%D1%82%D0%B8)
    - [22.3 Обработка изменения навигации](#223-%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D0%B8)
- [Ch 23. Особенности элементов роутинга](#ch-23-%D0%9E%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D1%80%D0%BE%D1%83%D1%82%D0%B8%D0%BD%D0%B3%D0%B0)
    - [23.1 Работа с](#231-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81)
        - [23.1.1 Выбор типа элемента](#2311-%D0%92%D1%8B%D0%B1%D0%BE%D1%80-%D1%82%D0%B8%D0%BF%D0%B0-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0)
        - [23.1.2 Выбор действия](#2312-%D0%92%D1%8B%D0%B1%D0%BE%D1%80-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F)
        - [23.1.3 Стилизация элементов](#2313-%D0%A1%D1%82%D0%B8%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
    - [23.2 Вложенные пути](#232-%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BF%D1%83%D1%82%D0%B8)
    - [23.3 Именованные элементы роутинга](#233-%D0%98%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D1%80%D0%BE%D1%83%D1%82%D0%B8%D0%BD%D0%B3%D0%B0)
- [Ch 24. Расширенные возможности роутинга](#ch-24-%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%80%D0%BE%D1%83%D1%82%D0%B8%D0%BD%D0%B3%D0%B0)
    - [24.1 Отдельные файлы для относительных путей](#241-%D0%9E%D1%82%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D0%BF%D1%83%D1%82%D0%B5%D0%B9)
    - [24.2 Защита путей](#242-%D0%97%D0%B0%D1%89%D0%B8%D1%82%D0%B0-%D0%BF%D1%83%D1%82%D0%B5%D0%B9)
        - [24.2.1 Глобальная защита](#2421-%D0%93%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B0)
        - [24.2.2 Защита для конкретного пути](#2422-%D0%97%D0%B0%D1%89%D0%B8%D1%82%D0%B0-%D0%B4%D0%BB%D1%8F-%D0%BA%D0%BE%D0%BD%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%83%D1%82%D0%B8)
        - [24.2.3 Порядок защитников](#2423-%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2)
        - [24.2.4 Защитники для компонентов](#2424-%D0%97%D0%B0%D1%89%D0%B8%D1%82%D0%BD%D0%B8%D0%BA%D0%B8-%D0%B4%D0%BB%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
    - [24.3 Загрузка компонентов по требованию \(ленивая\)](#243-%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%BF%D0%BE-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E-%D0%BB%D0%B5%D0%BD%D0%B8%D0%B2%D0%B0%D1%8F)
    - [24.4 Независимые компоненты](#244-%D0%9D%D0%B5%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)

<!-- /MarkdownTOC -->


## Ch 4. JS Basic

### 4.1 Подключение отладочных возможностей

возможность вызова `console.log()`:

* файл `package.json`
* добавить в `rules` `no-console: "off"`

### 4.2 Функции

#### 4.2.1 Определение функции через присваивание переменной

    const myFun = function() { 
        console.log("...");
    };

вызов: `myFun();`

#### 4.2.2 Простое определение функции

    function myFun() {
        console.log("...");
    }

вызов: `myFun();`

#### 4.2.3 Функция с параметрами по умолчанию

    function myFun(name, age = 20) { ... }

#### 4.2.4 Остаточные параметры (rest parameters)

внутрь функции передаются массивом

    function myFun(name, ...extraParams) {
        extraParams.forEach(...)
    }

вызов с произвольным количеством аргументов `myFun("Bob", 1, 2, 3);`

#### 4.2.5 Возврат результата

    function myFun() {
        return 1;
    }

#### 4.2.6 Функция как параметр другой функции

    function fun1(otherFun) {
        return "Hello, " + otherFun(); 
    }    
    
    colsole.log(fun1(function() {return "Alice";}));

#### 4.2.7 Лямбда-функции 

    const myFun = (a) => {console.log(a);}

### 4.3 Переменные и типы

#### 4.3.1 Объявление переменных

    const a = 5; неизменяемая переменная

    let b = 6; переменная с областью видимости в блоке, где объявлена

    var c = 7; область видимости - функция

внутренняя функция (объявленная внутри другой функции) имеет доступ к переменным внешней функции

#### 4.3.2 Примитивные типы

string, number, boolean

    let myBool = true;
    let string1 = "abc";
    let string2 = "def";

#### 4.3.3 Строки-шаблоны

    let message = `it is ${weather} today`

здесь `weather` - переменная в области видимости шаблона

### 4.4 Операторы

    ++, --
    &&, ||
    ?: - тернарный
    ==, != - равенство
    ===, !== - идентичность

при сравнении через `==` - преобразование к одному типу и сравнение
напр. `5 == "5" // true`, но `5 === "5" // false`

### 4.5 Преобразование типов

если среди операндов операции `+` есть строки - все преобразуются в строки

    5 + "3" // "53"

явное преобразование

    (6).toString();
    String(4);
    (6).toString(2); //
    (7.125).toFixed(2); //
    (..).toExponential(..)
    (..).toPrecision(..)

Функции преобразования строк

    Number(str)
    parseInt(str) // игнорируя нецифровые символы
    parseFloat(str) // аналогично


### 4.6 Массивы

#### 4.6.1 Основы

    let myArray = new Array();
    myArray[0] = 2;
    let myArr2 = [1, "Alix", 45];
    
    console.log(`Index 1: ${myArr2[1]}`);

Обход массива:
    
    // v1
    for (let i = 0; i < myArr2.length; i++) {...}
    
    // v2
    myArr2.forEach((value, index) => {...})

#### 4.6.2 Spread operator `...`

используется для разложения массива, когда нужно элементы массива в параметры функции

    function f(a, b, c) {...}
    let arr = [1, "ds", "we"];
    // можно так
    f(arr[0], arr[1], arr[2]);
    // или аналогично
    f(...arr);

### 4.7 Объекты

     // вариант 1
     let myData = new Object();
     myData.name = "Alice"; // добавляем свойство и присваиваем значение
     console.log(myData.name); // обращение к свойству

    // вариант 2: литералы
    let myData = {
        name: "Alice",
        age: 23
    };

    // можно захватывать переменные из контекста
    let name = "Alice";
    let myData = {
        name, 
        age: 30
    };

    // добавляем функцию
    let data = {
        name: "Bob",
        sayHello: function() {return this.name}
        // или без ключевого слова
        sayHelloAgain() { ... }
    };
    // здесь `this` - ссылка на сам объект

    // копирование свойств из другого объекта
    let data2 = {};
    Object.assign(data2, data);
    data2.sayHello();


### 4.8 Модули

отдельный файл `src/maths/sum.js`

    export default function(values) {...}

здесь `export` - означает, что можно функцию извне
`default` - если в модуле одна функция

Использование такой функции

    import addFunction from "./maths/sum"; 
    let total = addFunction([1, 2, 4]);

Важно: здесь при импорте задаем имя функции. Можно напр. несколько раз импортировать и под разными именами

Расположение модулей:

* `./math/...` - точка означает путь из той же папки, что и файл с импортом
* `@/math...` - `@` - путь начинается с корневой папки `src`
* `math` - если нет точки или `@`: внешняя зависимость из папки `node_modules` (при настройке проекта, через пакетный менеджер и т. п.)

Если модуль содержит несколько функций для импорта (`default` не используется)

    import {fun1, fun2} from "....";

Поменять имя c помошью **as**

    import {fun1, fun2 as sum} from "...";

Импорт всего модуля

    import * as ops from "...";
    ops.fun1();
    ops.fun2();

Комбинирование нескольких модулей:

    // создаем файл index.js внутри папки напр. `src/maths`
    // можем импортировать как обычно
    import fun1 from "...";
    
    // создавать свои функции
    export function fun2() {...}
    
    // экспортировать импортированные
    export {fun1};
    // экспортировать ф-и из других модулей
    export * from "./operations";

Теперь импортируем новый модуль

    import * as math from "./maths";
    math.fun1();
    math.fun2();


## Ch 9. Основы Vue

### 9.0 Предварительные действия

#### 9.0.1 Использование шаблонов

Рендеринг шаблонов по умолчанию отключен. Включение:

    // файл в корне проекта vue.config.js 
    module.exports = {
        runtimeCompiler: true
    }

Это позволяет указывать свойство **template** в объекте *Vue*, вместо `<template>`

#### 9.0.2 Подключение bootstrap

`npm install bootstrap@4.0.0`

импорт в файле `main.js`

    import "bootstrap/dist/css/bootstrap.min.css"


### 9.1 Объект Vue

#### 9.1.1 Скелет приложения

    // main.js
    require('../node_modules/bootstrap/dist/css/bootstrap.min.css')
    
    import Vue from "vue"
    new Vue({
        el: "#app",             
        template: `<div ...`
        })

здесь:
`el` - имя элемента в начальной странице, вместо кот. будет подставлен шаблон
`template` - шаблон

#### 9.1.2 Добавление данных

* Добавляем переменную в шаблон `{{myVar}}`
* Вставляем эту переменную в свойство **data** объекта Vue
* Переменная в шаблоне связана с изменением переменной в данных

Напр.

     new Vue({
        ..           
        template:  `<h1>
                        {{myVar}}
                    </h1>`,
        data: {
            myVar: 0
        }
    })    

#### 9.1.3 Обработчики событий

    new Vue({
        ..           
        template:  `<button class=".." v:on:click="onClick"`,
        methods: {
            onClick() {...}
        }
    })    

#### 9.1.4 Вычисляемые переменные

     new Vue({
        ..           
        template:  `<h1>
                        {{message}}
                    </h1>`,
        computed: {
            message() { return "abc";}
        }
    })    

### 9.2 Компоненты

#### 9.2.1 Основы 

Для отделения логики. Отдельный файл `.vue`

Скелет:

    // файл напр. App.vue
    <script>
    export default {
        template: `...`,
        data: ...
        // и т. д.
    }
    </script>

Основные моменты:

* Должен быть внутри блока <script></script>
* экспорт `export default`
* внутри блока **data** только функции

#### 9.2.2 Регистрация и применение

Импортировать перед применением (напр. в `main.js`)
Добавить в блок **components** объекта Vue
в блоке **components** компонент связывается с именем элемента HTML из шаблона
при рендеринге этот элемент будет заменен на компонент

    // main.js
    ...
    import MyComponent from "./App"
    new Vue({
        el: "#app",
        components: {"custom": MyComponent},
        template: `<h1>TEST</h1>
                    <custom/>`
    });

#### 9.2.3 Отделение шаблонов внутри файла

    // файл App.vue
    <template>
        <div>...</div>
    </template>
    
    <script>
        export default {....}
    </script>

#### 9.2.4 Разделение файлов шаблона и скрипта

    // файл src/App.html с шаблоном
    <div> ... </div>

    // файл src/App.vue
    <template src="./App.html" />
    <script>
        export default { ... }
    </script>


## Ch 11. Data binding

### 11.1 Структура компонентов

Определяется в файле `*.vue`

Состав:

* **template**
    - стандартные html-элементы
    - элементы Vue (напр. `{{msg}}`)
    - кастомные элементы, для связи с др. компонентами
    - шаблон с одним корневым элементом (напр. `<div>..</div>`)
* **script**
    - код для обеспечения работы шаблона (события, data-binding)
* **style**
    - необязательный
    - стиль определяет в целом для компонента


### 11.2 Отображение данных

#### 11.2.1 Связывание данных: Текстовая интерполяция

* в шаблоне **template** заводим переменную в `{{}}`
    - напр. `<h1>Hello, {{user}}</h1>`
* в блоке **script** определяем свойство **data**
    - в этом свойстве - функция, которая возвращает объект, свойства которого соответствуют переменным шаблона
    - `data: function() {return {user: "Alice"}}`

Если у объекта в **data** нет свойства для переменной в шаблоне, переменной будет присвоено значение `undefined`. Об этой ситуации будет только предупреждение в консоли, не на этапе компиляции (выход - TypeScript ??)


#### 11.2.2 Выражение в переменных шаблона

Vue считает содержимое **{{ }}** как js выражение. 
Поэтому можно сложные выражения строить

Ограничения:
* должно возвращать значения
* нельзя вызывать функции
* контекст выражения - это компонент, нельзя глобальные переменные и т. п.
* но есть доступ к основным функциям JS (Math, Number, String и др.)

### 11.2.3 Computed свойства

В шаблонах не рекомендуется сложные выражения использовать.
Для этого блок **computed**
В нем содержится объект-литерал со свойствами, используемыми в шаблоне
В шаблоне к вычисляемым свойствам обращение такое же, как к свойствам-данным

    ...
    data: function() {
        return {
            price: 54,
            tax: 20
    }},
    computed: {
        total: function() {
            return this.price * this.tax / 100;
        }
    }

data-свойства реактивны: при любом изменении data-свойств, будут вызываться computed-функции

Следует избегать side-эффектов: функции не должны менять значения data-свойств
    
### 11.2.4 Методы

В блоке **methods** можно объявлять вспомогательные функции

    ...
    computed: {...},
    methods: {
        getTotal(firstParam) { ... }
    }

Эти функции могут иметь аргументы
Внутри функций можно обращаться к data-свойствам через `this`

Вызов методов внутри функций блока **computed** - через `this`

Вызов методов в выражении в шаблоне - без `this`

Вопрос: лучше вызвать метод в шаблоне или ввести вычисляемое свойство?
Ответ: зависит от, стремиться не усложнять шаблон

### 11.2.5 Фильтры

блок **filters**, в нем определяются функции
возвращают форматированный результат и вызываются обычно в шаблонах

    data: {},
    filters: {
        currency(value) {
            return ...
        }
    }

вызов в шаблонах через `|`

    <div>
        <h1> {{someFun()|currency}}</h1>
    </div>

Внутри функций фильтров нет доступа к свойствам компонента, можно передавать через доп. параметры

Функции фильтров можно выстраивать в цепочки:
    
    ...
    <h1> {{currency|reverse|capitalize}}</h1>
   
Можно глобально регистрировать

## Ch 12. Базовые директривы

### 12.1 Основы

Добавляют функциональность html-элементам в шаблоне
Начинаются с `v-`

схема: `<element v-dir:attrArg="expression">`

Применяются как атрибуты тегов

### 12.2 Вывод текста

**v-text="выражение"** - устанавливает текст для элемента html. Именно как текст, html экранируется
Значение атрибута - выражения как для текстовой интерполяции  

    <h1>Product <span v-text="prodName"></span></h1>

### 12.3 Вывод html

**v-html="выражение"** - аналогично **v-text**, но может вставлять html-код и перестраивать страницу. Не применять для недостоверных источников - риск XSS-атаки

### 12.4 Условные директивы

#### 12.4.1 if

**v-if="выражение"** - условное отображение тега, в зависимости от значения выражения (истинно / ложно). При изменении значения выражения создает / разрушает элементы вместо сокрытия их через css (как это делает **v-show**)

    <h4 v-if="true">1 2 3 4</h4>

Ложь в JS:

* булево false
* 0
* "" пустая строка
* null
* undefined
* NaN

Если нужно управлять видимостью у нескольких элементов сразу (напр. элементы списка) можно след. подход (вместо дублирования атрибута **v-if**)

    <li>list item</li>
    <<template v-if="flag">
        <li>{{name}}</li>
        <li>{{price}}</li>
    </template>

#### 12.4.2 else и else-if

**v-else** - применяется сразу после **v-if** и отображает элемент противоположно элементу с **v-if**, не требует выражения

    <h1 v-if="showFlag">Some text</h1>
    <h1 v-else>Another text</h1>

**v-else-if** - между **v-if** и **v-else**. Имеет собственное выражение. Может быть несколько. Если **v-if** ложно, проверяются **v-else-if**, если все они ложны, отображается элемент с **v-else**

    <h1 v-if="showFlag">Some text</h1>
    <h1 v-else-if="showFlagNum2">Other text</h1>
    <h1 v-else>Another text</h1>    

#### 12.4.3 show

**v-show** - аналог **v-if**, но не разрушает/создаем объекты (изменяет DOM), а меняет свойство элементов `display`, не уничтожая объекты (не меняя DOM)
Для **v-show** нет аналогов **v-else** / **v-else-if**

### 12.5 Установка атрибутов элемента (v-bind)

#### 12.5.1 Установка class

**v-bind** - устанавливает атрибут у элемента. Часто это `class`. 
Есть сокращение без v-bind `:class=".."`

вариант использования через массивы, где в массиве перечисляются классы

    <div v-bind:class="elemClass">... </div>
    ...
    computed: {
        elemClass() {
            return this.flag
            ? ["bg-light", "text-dark"]
            : ["bg-dark", "text-light"];
        }
    }

вариант использования через объекты, где свойство объекта - имя класса, а значение переключает использование (булево)

    ...
    computed: {
        elemClass() {
            return {
            "bg-light": this.flag,
            "text-light": !this.flag};
        }
    }

можно использовать вместе со стандартным атрибутом `class`
    
    <div v-bind:class="elemClass" class="display-4">... </div>

#### 12.5.2 Установка стиля

Определение стиля через **v-bind**

    <div v-bind:style="elemStyle">... </div>
    computed: {
        elemStyle() {
            return {
                "border": "5px red",
                "background-color": this.flag ? "coral": ""};
        }
    }  

#### 12.5.3 Установка пользовательских атрибутов

Добавление пользовательских атрибутов (по соглашениям html пользовательские начинаются с префикса `data-`)

    <h3 v-bind:data-size="size">Product: {{name}}</h3>

Установка нескольких атрибутов: выражение в директиве возвращает объект, где имя свойства - атрибут, значение - его значение

    computed: {
        attrValues() {
            return {
                class: this.highlight ? ["bg-light", "text-dark"] : [],
                style: {
                    border: this.highlight ? "5px solid red": ""
                },
                "data-size": this.highlight ? "big" : "small"
        }
    }

    

## Ch 13. Директивы-циклы

### 13.1 Директива v-for

#### 13.1.1 Основы

    <tr v-for="p in products">
        <td>{{p.name}}</td>
        <td>{{p.price}}</td>

здесь `products` - свойство из **data**, массив
`p` - псевдоним для текущего элемента

Обычно требуется для каждой строки ключ. linter будет предупреждать если нет

    <tr v-for="p in products" v-bind:key="p.name">...</tr>

#### 13.1.2 Работа с индексами

Заводим переменную (начинается с 0)

    <tr v-for="(p, i) in products" v-bind:key="p.name" v-bind:odd="i % 2 == 0">

#### 13.1.2 Расширенная форма (template)

    <template v-for="(p, i) in products>"
        <tr v-bind:key="p.name" v-bind:odd="i % 2 == 0">...</tr>

#### 13.1.3 Изменения в массивах

Vue может отслеживать изменения в массив при вызове методов `push, pop,shift, sort` и т.п. 
При пересоздании массива (методы `filter, slice`) нужно присваивать свойству новый массив. Vue аккуратно это обработает без рендинга целой страницы

Не может отслежить вставку в массив (напр. `this.arr[1] = ...;`)
Для отсеживания можно использовать спец. метод

    import Vue from "vue";
    ...
    Vue.set(this.arr, index, newValue);

Также Vue не отследит сокращение массива через изменение свойства lenght, но вместо этого можно метод `slice`

### 13.2 Перечисление свойств объекта

####  13.2.1 Вывод объекта через v-for

Вместо массива можно использовать объект с набором свойств

    ...
        <tr v-for="(p, key, i) in products" v-bind:key="p.name">...</tr>
    ...
    data: {
        function() {
            return {
                products {
                    1: {name:"a", price: 3},
                    2: {name:"b", price: 4}
                }
            }
        }
    }

Здесь `key` - имя свойства из объекта `products`

Вставка новых свойств также работает через `Vue.set`

#### 13.2.2 Порядок вывода свойств объекта

Свойства объекты выводятся в порядке определяемом ключом свойств:

* сначала ключи в виде целых чисел или строки целых чисел по возрастанию
* остальные ключи - в порядке определения

### 13.3 Циклы без данных

**v-for** можно для повторений ссылки на объект или массив.
Например для разбиения на страницы

    ...
    <button v-for="i in 5" v-on:click="handleClick(i)">{{i}}</button>

Здесь элемент повторяется для i = 1..5



## Ch 14. Обработка событий

### 14.1 Основы

Директива `v-on:<argument>="expression"`

Напр. так 
    
    <h1 v-on:click="name='Hello'">{{name}}</h1>

### 14.2 События и объекты событий

Перечень событий [dev](https://developer.mozilla.org/en-US/docs/Web/Events)
Напр. `click`, `mousedown`, `mousemove`, `keydown` и др

Каждое событие создает объект, описывающий событие 
Объект содержит разные свойства, напр.:
* **target** - DOM элемент, соответсвующий html-элементу, вызвавшему событие
* **currentTarget** - элемент, обрабатывающий событие
* **type** - тип события
* **key** - для событий клавиатуры

В директиве **v-on** доступ к объекту события - через переменную **$event**

    <h1 v-on:click="name=$event.type">{{name}}</h1>

### 14.3 Методы для обработки событий

Выражение в директиве - можно вызов метода.
Если параметры при вызове не заданы, первым по умолчанию будет `$event`

    ...
    <h1 v-on:click="handleClick">{{name}}</h1>    
    ...
    data: function() {
        return {
            name: "Alice"
        }
    },
    methods: {
        handleClick(event) {
            this.name = event.type;
        }
    }

Можно свои параметры задавать

    <h1 v-on:click="handleClick(42, $event)">{{name}}</h1>

Есть короткая форма директивы: `@click=...` вместо `v-on:click=...`

### 14.4 Обработка нескольких событий на одном элементе

**Вариант 1**: просто перечисляем несколько директив в одном элементе
Обработчики можно общие (разделение логики - через параметр `$event`)

    <button 
        v-on:click="handleClick"
        v-on:mousemove="handleMouseEven($event)"
        v-on:mouseleave="handleMouseEven($event)"> Click </button>

**Вариант 2**: одна директива **v-on** без аргумента-события. В качестве выражения - объект: ключи-свойства - имена события, значения - обработчики

    <button v-on="buttonEvents">Click</button>
    ...
    data: function() {
        return {
            buttonEvents {
                click: this.handleClick,
                mousemove: this.handleMouseEvent
            }
        }
    }

При этом методы-обработчики в качестве параметров могут принимать только `$event`. Чтобы передать доп. параметры можно сделать так:

    //добавляем атрибут к кнопке (name - псевдоним из v-for)
    <button v-on="buttonEvents" v-bind:data-name="name"></button>
    ...
    //в обработчике получаем его значение (dataset содержит значения атрибутов)
    let name = $event.target.dataset.name; 

### 14.5 Модификаторы событий

#### 14.5.1 Распространение событий

Модификаторы **stop**, **capture**, **self** регулируют движение события через иерархию html-элементов.

В общем событие имеет три фазы:

* фаза **capture**:
    - событие передается от верхнего родительского элемента к элементу-цели вниз по иерархии
    - по умолчанию элементы не обрабатывают эту фазу
    - нужно явно указывать `... v-on:click.capture=...`
    - свойство *target* объекта событие - элемент, на котором произвошло событие, *currentTarget* - текущий элемент в иерархии
* фаза **target**:
    - вызывается обработчик на том элементе, на котором вызвано событие
    - свойства *target* и *currentTarget* совпадают
* фаза **bubble**:
    - событие передается к родительским элементам вверх по иерархии
    - на родительских элементах вызываются обработчики
    - свойства *target* и *currentTarget* НЕ совпадают

Модификатор **self** запрещает вызов обработчика у элемента на bubble-фазе, только на target-фазе

    ...v-on:click.self=...

Модификатор **stop** прекращает движение события после обработки

    ...v-on:click.stop=...

Модификаторы можно комбинировать. Порядок важен
    
    ...v-on:click.self.stop=...

#### 14.5.2 Модификатор once

Гарантирует вызов только один раз (напр. два раза нажатие - один раз обработка)
Не останавливает распространение события

    v-on:click.once="..."

### 14.6 События мыши

Модификаторы на кнопки **left**, **right**, **middle**
На элементе, к которым они применены не будут обрабатываться события других кнопок, но эти события будут распространятся

### 14.7 События клавиатуры

модификаторы на конкретные клавиши: **enter**, **tab**, **delete**, **esc**, **alt**, **ctrl** и др.
Работают при нажатии напр. `Ctrl+любая`

модификатор **exact** - только на конктретную, не в связке напр. `Ctrl+Shift`

    <input v-on:keydown.ctrl="handle"/>
    ...
        handle(event) {
            console.log(event.key);
        }


## Ch 15. Работа с элементами форм

### 15.1 2-way binding

Изменения на форме изменяют данные (блок *data*)
Изменения данных должны менять данные на форме

    <input type="checkbox"
        v-on:change="handleChange" // это с формы в данные
        v-bind:checked="dataValue" // это из данных на форму
    />
    ...
    data: {
        return {
            dataValue: false
        }
    },
    methods: {
        handleChange() {this.dataValue = $event.target.checked;}
    }

Вот пример для текстового поля:

    <input type="text"
        v-on:input="handle"
        v-bind:value="textValue"
    />

### 15.2 Директива v-model

Обеспечивает 2-way binding для элементов *text*, *select*, *textarea*
Выражение в директиве - это свойство из данных

    <input type="text" v-model="textValue"/>
    ...
    data: {
        return {
            textValue: ""
        };
    }

### 15.3 Использование v-model для элементов ввода

#### 15.3.1 Текстовые поля

    <input v-model="name"/>
    <input type="password" v-model="password"/>
    <textarea v-model="details"/>

#### 15.3.2 Радиокнопки

    <input type="radio" v-model="name" value="Alice"/>
    <input type="radio" v-model="name" value="Bob"/>

или через **v-for**

    <div v-for="n in allNames" v-bind:key="n">
        <input type="radio" v-model="name" v-bind:value="n"/>
    </div>

#### 15.3.3 Checkboxes

    <input v-model="boolValue" type="checkbox"/>

#### 15.3.4 Select element

Также можно через перечислением или через **v-for**

    <select v-model="name">
        <option value="all">all</option>
        <option v-for="n in allNames" v-bind:key="n" 
                v-bind:value="n">{{n}}</option>
    </select>

### 15.4 Модификаторы v-model

#### 15.4.1 number

Для элемента *input* можно указать тип `number`. Это позволит вводить только цифры. Но js введенный результат будет считать строкой. Модификатор **number** конвертирует в число

    <input type="number" v-model.number=".." />

#### 15.4.2 lazy

По умолчанию данные обновляются при каждом нажатии кнопки в текстовых полях. Модификатор **lazy** откладывает обновление до перехода на другой элемент

    <input type="number" v-model.lazy=".." />

#### 15.4.3 trim

Убирает whitespace при вводе. Работает только при прользовательском вводе, не работает при установке значения через **data**

    <input type="text" v-model.trim=".." />


### 15.5 Связывание со сложными типами данных

#### 15.5.1 Селекторы для массива

Массив можно связать с checkbox`ами. Тогда установка/снятие отметки будет добавлять элементы в массив

    <div v-for="city in cityNames" v-bind:key="city">
        <label>
            <input type="checkbox" v-model="cities" v-bind:value="city" />
        </label>
    </div>

Здесь `cityNames` - массив с перечнем доступных значений, а `cities` - массив, который будет содержать выбранные значения

#### 15.5.2 Преобрахование значения Checkbox в другие типы

Часто значение переключателя не используется напрямую, а на его основе вычисляется свойство или выражение

    <div v-bind:class="elemClass"> ... </div>
    ...
    <input type="checkbox" v-model="dataValue" />
    ...
        computed() {
            elemClass() { return this.dataValue ? "bg-prim" : "bg-info"}
        }

Такое можно упростить через атрибуты **true=value**, **false-value**

    <input type="checkbox" v-model="dataValue" true-value="bg-prim"
        false-value="bg-info" />
    
    // computed свойства не нужны

#### 15.5.3 Пользовательские значения для селекторов и radio buttons

C **v-model** можно использовать **v-bind** для задания значений

    <input type="checkbox" v-model="dataValue"
        v-bind:true-value="darkColor"
        v-bind:false-value="lightColor"  /> 
    
    <select v-model="dataValue">
        <option v-bind:value="darkColor">Dark</option>
        <option v-bind:value="lightColor">Light</option>
    </select>
    
    <input type="radio" v-model="dataValue" v-bind:value="darkColor">
    
    data function() {
        return {
            darkColor: "bg-primary",
            lightColor: "bg-info"
            dataValue: "bg-info"
        }
    }


## Ch 16. Компоненты

### 16.1 Компоненты как строительные блоки

#### 16.1.1 Основы

Компоненты определяются в файлах `.vue` в `src/components`
Каждый компонент содержит минимум блок *template*

#### 16.1.2 Дочерние компоненты

Компонент может включать дочерние компоненты.
Для этого 3 шага:

* импортируем компонент `import SomeComp from "./components/Child`
    - имя можно задавать произвольное (значимое для родительского компонента)
    - это имя потом используется в шаблоне и при регистрации
* регистрируем компонент (под тем же именем, что импортировали)
    - `components: { SomeComp}`
* вставить в шаблон родителя дочерний компонент 
    - `<div> <SomeComp/> ...`
    - в процессе работы будет заменен на содержимое дочернего

#### 16.1.3 Имена компонентов и элементов

При импорте можно задать любое имя

    import MyName from "./components/Child"

Именно это имя будет значением свойства при регистрации компонента, но имя свойства может быть произвольным

    components: {
        MyComponent: MyName
    }

Теперь имя свойства должно использоваться в шаблоне. Причем допускается преобразование camelCase в дефисную нотацию

    <MyComponent/>
    <my-component/> 

#### 16.1.4 Глобальная регистрация компонентов

Один раз регистрируем, доступен во всех других компонентах без доп. настроек

В файле `main.js`

    import Child from "...";
    Vue.component("child-component", Child);
    
    new Vue(...).$mount('#app')


### 16.2 Изоляция и связанность компонентов

#### 16.2.1 Изоляция

Компоненты работаю в изоляции.
Напр. один компонент несколько раз использован в родительской шаблоне. Свойства каждого такого экземпляра независимы.
Или родительский компонент и дочерний имеют свойства с одинаковыми именами. Эти свойства также независимы.

#### 16.2.2 CSS scoping

Стиль примененный к компоненту по умолчанию применяется ко всем дочерним компонентам

    <style>
        div {border: red;}
    </style>

Если не нужно применять стиль к дочерним (дочерние имеют собственный стиль) применяется атрибут **scoped**

    <style scoped>
        ...
    </style>


#### 16.2.3 Props компонентов

##### 16.2.3.1 Назначение

Используются для обеспечения взаимодействия между компонентами
Определяются как массив строковых имен для свойства с имененем **props**

    <script>
        export default {
            props: ["labelText", "anotherText"],
            data ...
        }
    </script>

Определенные таким образом свойства, могут использоваться везде в компоненте, напр. в текстовой интерполяции

    <label>{{labelText}}</label>

Значения таких свойств передаются только в одном направлении: от родителя к дочернему компоненту.

Изменение *prop* свойства в дочернем компоненте может быть перезаписано родителем, поэтому обычно значение *props* используют как начальное значение для *data* или *computed* свойства. А это *data*-cвойство используется на форме (v-model)

##### 16.2.3.2 Использование props в родительском компоненте

Передача значений в дочерние происходит через атрибуты пользовательских html-элементов

    <my-component label-text="Hello" init-value="Alice" />

Здесь также работает преобразование верблюжей нотации в дефисную

Значения prop-атрибутов это литералы, не выражения
Если нужно передать выражения - используется **v-bind**

##### 16.2.3.3 Установка стандартных атрибутов

При вставке шаблона дочернего элемента значения стандартных атрибутов (не *props*) передаются от родителя в дочерние. 

Напр. шаблон дочернего компонента

    <div id="childId"> This is child </div>

Шаблон родителя

    <my-component id="parentId" />

При вставке получим результирующий шаблон
    
    <div id="parentId"> This is child </div>

Для атрибутов **class** и **style** работает объединение.

В общем следует избегать ситуации, когда родитель и дочерние компоненты имеют одинаковые атрибуты

##### 16.2.3.4 Передача значений через выражения

    <input type="text" v-model="labelText"
    <my-component v-bind:label-text="labelText" init-value="some text" />
    ...
    data
    ...
        labelText: "Name"

Здесь в дочерний компонент передаются два атрибута. Один (`init-value`) просто через атрибут и так передается конкретное неизменяемое значение.
Второй - через **v-bind**. Любые изменения свойства `labelText` будут передаваться в дочерний компонент (но не наоборот)

### 16.3 Передача данных от дочернего компонента родителю

Реализуется через пользовательские события

I. В дочернем элементе вызываем метод `$emit(p1, p2)`. Первый параметр - произвольный строковый идентификатор события, второй - произвольные данные, передаваемые в обработчик. Напр. так:

    <template>
        ...
        <button v-on:click="doSubmit">Submit</button> 
    ...
    methods: {
        doSubmit() {
            this.$emit("productSubmit", this.product);
        }
    }

II. В родительском шаблоне подключаем обработчик через **v-on**
    
    <template>
        ...
        <my-component v-on:productSubmit="updateProduct">
    ...
    methods: {
        updateProduct(newProduct) {...}
    }


### 16.4 Слоты

#### 16.4.1 Основы

Задача: родитель может требовать отображения элементов в дочерних компонентах.

Для этого в дочернем шаблоне вставляют блок **slot**
    
    // Child.vue
    <tempalate>
        ...
        <slot> Default text </slot>
        ...
    </template>

Теперь если в родительском шаблоне будут элементы между начальным и конечным пользовательскими тегами, это содержимое будет вставлено в дочерний шаблон

    // App.vue
    <template>
    ...
    <my-component ...> <h1> hello from parent </h1> </my-component>

Если в родительском шаблоне нет содержимого, будет содержимое блока **slot** из шаблона дочернего компонента

#### 16.4.2 Именнованные слоты

В шаблоне дочернего компонента у тега **slot** применяем атрибут **name**.
В шаблоне родителя используем атрибут **slot**. Таким образом можно использовать несколько слотов одновременно

    // parent
    <slot name="s1"></slot>
    ...
    <slot name="s2"></slot>

    // child
    <my-component>
        <div slot="s1">...</div>
        ...
        <div slot="s2">...</div>



## Ch 17. Жизненный цикл компонентов

### 17.0 Основы

Компоненты имеют жизненный цикл от создания, использования и до разрушения.
Компонент может реализовать методы жизненного цикла, которые будут вызываться на определенных этапах

### 17.1 Фаза создания

На этом этапе компонент создается и настраивается для использования (обрабатываются *data-* и *computed-* свойства) 

Два метода могут вызываться: **beforeCreate()** и **created()**. Первый вызывается до инициализации data-свойств (значения свойств в этом методе - `undefined`), второй - после.

В компонентах методы жизненного цикла определяются сразу в секции **script** (не внутри **methods**)

    export default {
        data: function() {
            return {
                flag: true
            }
        },
        beforeCreate() {..},
        created() {}
    }

В методе **beforeCreate()** уже существует ссылка this и ей присвоен объект. К этому объекту будут присоединяться свойства (data, computed), методы из *methods*. Но это будет позже. На этапе **beforeCreate** объект пустой. На этапе **created** уже заполнен.

Также в процессе создания выполняются мероприятия по обеспечению реактивности. Так например для каждого свойства из **data** в объект компонента добавляется свойство и геттеры/сеттеры. Таким образом, все реактивные свойства должны быть определены до создания объекта (секция script).

### 17.2 Фаза монтирования

На этом этапе работа с шаблоном, data binding, директивами и т. п.

Метод жизненного цикла - **mounted()**

Внутри этого метода есть возможность доступа к DOM через переменную **$el**.
Но следует избегать такого подхода

    data: {
        ...
        names: []
    },
    mounted() {
        this.$el.dataset.names.split(",").forEach(n => this.names.push(n));
    }

В примере data-свойство `names` заполняется значениями из пользовательского атрибута `data-names`, установленного в корневом теге.

### 17.3 Фаза обновления

После создания и монтирования компонента. Отслеживает изменение своих свойств. При изменении вызываются **beforeUpdate()** (изменение обнаружено, но не обработано)и **updated()** (изменение обработано)

Также есть доступ к DOM, но не рекомендуется

Методы вызываются, когда изменяются html-элементы, не просто данные

### 17.4 Отслеживание изменений через watch

#### 17.4.1 Свойство watch

Методы update не сообщают какие именно изменения были сделаны и вызываются только когда меняются html-элементы, а не просто data-свойства

метод **watch()** позволяет отслеживать изменения data-свойств

    data: function() {
        checked: false
    },
    watch: {
        checked: function(newValue, oldValue) { ... }
    }

Задаются в свойстве **watch** как свойства с именем равным data-свойству и значением - функцией-обработчиком

#### 17.4.2 Дополнительные настройки watch

Можно указать вызывать **watch** во время фазы создания. 

    watch: {
        checked: {
            handler: function(new, old) {...},
            immediate: true
        }
    }

Можно назначить один обработчик на отслеживание всех data-свойств

    watch: {
        myObject: {
            handler: function(new, old) {...},
            deep: true
        }
    }


### 17.5 Фаза разрушения

Обычно проявляется для динамический компонентов
Вызываются **beforeDestroy()**, перед собственно уничтожением и **destroed()**

Не стоит сильно полагаться на эти методы. В некоторых случаях можно не дождаться вызова

### 17.6 Обработка ошибок

#### 17.6.1 Основы

Компонент может перехватывать ошибки от дочерних компонентов с помощью функции **errorCaptured()**. Перехватываются ошибки:

* во время изменения data-свойств
* от функций **watch**
* от методов жизненного цикла

Не перехватываются ошибки от обработчиков событий

Метод **errorCaptured()** имеет три параметра: 

* error - ощибка
* component - компонент - источник ошибки
* source - строковое описание, что происходило во время возникновения ошибки

Если метод вернет false, ошибка не будет передана по иерархии дальше

Обычный шаблон: заводим флаг ошибки, через **v-if** и флаг отображаем, в обработчике **errorCaptured()** устанавливаем флаг

#### 17.6.2 Глобальный обработчик ошибок

Объявляется в главном файле `main.js`

    Vue.config.errorHandler = function(error, component, source) {..}
    
    new Vue({...})



## Ch 18. Слабо связанные компоненты

Как обеспечить взаимодействие между компонентами (кроме способа через **props**)

### 18.1 Внедрение зависимостей

#### 18.1.0 Основы

Позволяет определять сервис (любое значение, функция, объект) и сделать его доступным любым потомкам. При этом приемник не обязан быть прямым дочерним компонентом источника, но должен быть в иерархии источника

#### 18.1.1 Объявление сервиса

В корневом компоненте добавляем свойство **provide**. Значение как у **data** - функция, возвращающая объекты. Доступ к этому объекту будет у всех других компонентов, так как они потомки основного компонента

    export default {
        name: "App",
        provide: function() {
            return {
                colors: {
                    bg: "bg-secondary",
                    text: "text-white"
                }
            }
        }
    }

#### 18.1.2 Подключение сервиса через внедрение зависимостей

Свойству **inject** компонента присваивается массив строковых имен переменных, в которые будут передаваться значения

    <input v-bind:class="[colors.bg, colors.text]" />
    ...
    export default {
        inject: ["colors"]
    }

#### 18.1.3 Переопределение сервисов

Когда Vue создает компонент со свойством **inject**, он ищет в родителях соответствующее свойство **provide** постепенно поднимаясь по иерархии. Таким образом компоненты могут переопределеть сервисы от вышестоящих компонентов

#### 18.1.4 Реактивные сервисы

Для обеспечения реактивности в источнике создаем объект в **data** и его используем в сервисе. Теперь изменения в этом объекте будут распространяться по приложению при изменении в родителе.

Но опять же изменения от дочернего в родитель не передаются

    ...
    data: function() { return {
        reactiveColors: {
            bg: ..,
            text: ...
        }
        }},
    provide: function() { return {
        colors: this.reactiveColors
        }}

#### 18.1.5 Другие свойства сервисов

На стороне приемника можно:
* обеспечить значение по умолчанию, если сервис не определен
* поменять имя, под которым свойство сервис известен в компоненте-приемнике

Для этого значение свойства в **inject** делаем объектом.
Имя свойства - то имя под которым сервис будет известен в текущем компоненте
Значение свойства **from** - то имя под которым сервис зарегистрирован в источнике. В свойстве **default** указано значение по умолчанию (общий шаблон: `() => что-то по умолчанию`, в примере - функция)


    ...
    inject: {
        format: {
            from: "labelFormatter", 
            default: () => (value) => `Default ${value}`
        }
    }


### 18.2 Event Bus

#### 18.2.1 Создание шины

Позволяет передавать сообщения между компонентами, не связанными отношением родитель-потомок

Первый шаг - объявить сервис в объекте Vue. Через него будем передавать / принимать события

    // файл main.js
    new Vue ({
        render: h => h(App),
        provide: function() {
            return {
                eventBus: new Vue()
            }
        }
    }).$mount('#app')

#### 18.2.2 Отправка событий по шине

Получаем объект-шину и через метод **$emit()** отправляем сообщения

    export default {
        inject: ["eventBus"],
        methods: {
            createNew() { this.eventBus.$emit("create")},
            edit(product) { this.eventBus.$emit("edit", product)}
        }
    }

Здесь "create" и "edit" - пользовательские идентификаторы событий. Нужно следить за их уникальностью в пределах приложения

#### 18.2.3 Получение событий

Для этого регистрируем событие программно через **$on()** при создании компонента

    ...
    inject: ["eventBus"],
    created() {
        this.eventBus.$on("create", this.startCreate)
    }

#### 18.2.4 Локальная шина событий



## Ch 19. Взаимодействие с RESTFul сервисами

### 19.1 Механизмы HTTP запросов

* **XMLHTTPRequest** - старый способ. Работает во всех браузерах
* **Fetch API** - замена, работает на промисах
* библиотеки-обертки, например *Axios*

### 19.2 Cross-origin запросы

Браузеры и JS запрещают выполнять http-запросы к другим источникам, только к одинаковым источникам (принцип одинакового источника).
Источники одинаковы если у них совпадают: протокол, домен, порт

Это проблема для разработчиков, т.к. приложения часто обращаются к другим источникам. Решение - протокол Cross-Origin Resource Sharing (CORS). 

Axios автоматически поддерживает CORS. В других случаях надо смотреть

### 19.3 Выполнение запроса

Axios позволяет выполнять разные виды запросов(`get()`, `post()`) или универсальный `request()`

    <script>
        import Axios from "axios";
        let baseUrl = "http://localhost:3500/products";
        ...
        created() {
            Axios.get(baseUrl).then(resp => {
                    this.proccessProducts(resp.data);
                });
        }
    </script>

Запросы обычно выполняются в `created()` или `mounted()`. Выбор - за разработчиком, но последовательно в одном месте

метод `get()` возвращает Promise с объектом запроса с полями:
* status - код ответа (200 / 400 / 500) 
* statusText - текстовое представление ("Ok")
* headers - объект с заголовками
* data -  содержимое запроса, распарсенный json
* config - конфигурация запроса
* request - объект XMLHttpRequest

Можно через **acync/await**:

    acync created() {
        let data = (await Axios.get(url)).data;
        this.proccessProducts(data);
    }

### 19.4 Создание отдельного сервиса для запросов

Можно выделить код, выполняющий запросы из компонента

I. Создаем файл `restDataSource.js` и в нем создаем объект, выполняющий запросы

    // restDataSource.js
    import Axios from 'axios';
    const url = "...";
    export class RestDataSource {
        async getProducts() {
            return (await Axios.get(url)).data;
        }
    }

II. Подключаем экземпляр объекта к приложению

    // main.js
    ...
    import { RestDataSource } from "./restDataSource";
    ...
    new Vue({
        ...
        provide: function() {
            return {
                eventBus: new Vue(),
                restDataSource: new RestDataSource()
            }
        }
        }).$mount('#app')

III. Используем в компонентах

    ....
    inject: ['eventBus', 'restDataSource'],
    async created() {
        this.proccessProduct(await this.restDataSource.getProducts());
    }

### 19.5 Различные HTTP операции

     async saveProduct(product) {
        await Axios.post(url, product);
    }
    async updateProduct(product) {
        await Axios.put(`${url}${product.id}`, product);
    }
    async deleteProduct(product) {
        await Axios.delete(`${url}${product.id}`, product);
    }

**await** здесь позволяет убедиться что операция действительно выполнилась, и клиент не показал состояние отличное от состояния сервера. При неуспешном завершении операции (ошибках на стороне сервера) будет вызвано исключение на клиенте и прекращено выполнение кода в компоненте

### 19.6 Сервис для обработки ошибок

I. Сервис для запросов теперь будет выполнять запросы в блоке try-catch и по шине событий пересылать сообщения об ошибке. Шину в класс RestDataSource передаем через конструктор

    // restDataSource.js
    export class RestDataSource {
        constructor(bus) {
            this.eventBus = bus;
        }
    }
    async saveProduct(product) {
        await this.sendRequest("POST", url, product);
    }
    async sendRequest(method, url, product) {
        try {
            return await Axios.request({
                method:method,
                url:url,
                data:product
                });
        } catch(err) {
            if(err.responce) {
                this.eventBus.$emit("httpError", `${err.responce.statusText}`)
            } else {
                this.eventBus.$emit("httpError", "HTTP error")
            }
            throw err;
        }
    }

Здесь работаем через универсальный метод `sendRequest()`. В нем ошибка возникает если сервер вернул ответ с кодами 400-500 или вообще не ответил.
В конце вызываем исключение дальше, чтобы компоненты знали и не продолжали логику свою.

II. Дальше компонент реагирует на событие `httpError` и по нему устанавливает видимость блока с ошибкой (через **v-if** например)


## Ch 20. Data Store (Vuex)

### 20.1 Создание и использование Data Store (хранилища)

#### 20.1.1 Создание

`npm install vuex`

Создаем файл `index.js` в `src/store`

    // src/store/index.js
    import Vue from 'vue';
    import Vuex from 'vuex';
        
    Vue.use(Vuex); // включаем использование Vuex (как плагина)
    
    export default new Vuex.Store({
        state: {
            products: [...]
        },
        mutations: {...}
    })

#### 20.1.2 State и мутации

При создании хранилища задается его начальное состояние (через свойство **state**). Напрямую менять это состояние нельзя, только через мутации.

    ...
    state: {
        products: [
            {id: 1, name: "p1", price: 10},
            {id: 2, name: "p2", price: 20} ]   
    }
    ...

Мутации - это функции, которые принимают первым параметром текущее состояние хранилища и любые доп. параметры

    mutation: {
        updateProduct(currentState, index, product) {
            Vue.set(currentState.products, index, product);
        }
    }

#### 20.1.3 Доступ к хранилищу из компонентов

Через конфигурацию главного Vue объекта. Импортируем объект хранилища и присваиваем свойству **store** объекта Vue. Теперь компоненты имеют к нему доступ через переменную **$store**

    import store from "./store"; // без указания файла т.к. index.js
    
    new Vue({
        render: ..,
        data: ...,
        store,
        ...
    })

Доступ можно получить из любого скрипта в приложении, не обязательно компонента, но через импорт `import dataStore from "../store";`

#### 20.1.4 Использование хранилища

Доступ к состоянию хранилища реализуется через вычисляемое свойство.
Изменения выполняются через метод `commit()`. Первым параметром передается строковое имя функции-мутации, остальные параметры - параметры для этой функции

    computed: {
        products() {
            return this.$store.state.products;
        }
    },
    methods: {
        update(index, product) {
            this.$store.commit("updateProduct", index, product);
        }
    }

### 20.2 Вычисляемые свойства в хранилище (геттеры)

#### 20.2.1 Геттеры

Компоненты могут выполнять над хранилищем одни и те же операции. Доля выделения можно использовать механизм геттеров - аналог вычисляемых свойств

Добавляются в свойство **getters** хранилища. Первый параметр - состояние хранилища, вторым можно передать ссылку на геттеры для вызова других геттеров.

    ...
    state: { ... },
    getters: {
        orderedProducts(state) {
            return state.products.concat().sort((p1, p2)=>p2.price - p1.price);
        },
        filteredproducts(state, getters) {
            return getters.orderedProducts.filter(p => p.price > 100);
        }
    } 

Геттеры НЕ ДОЛЖНЫ менять состояние хранилища (только через мутации). В примере вызывается метод `concat()`, который создает новый массив в отличие от `sort()`

#### 20.2.2 Использование в компонентах

Обычно в вычисляемых свойствах через свойство **$store.getters**

    ...
    computed: {
        products() {
            return this.$store.getters.filteredProducts;
        }
    }

#### 20.2.3 Передача аргументов в геттеры

Для этого геттер делают функцией

    ...
    getters: {
        filteredProducts(state) {
            return (amount) => state.products.filter(p => p.price > amount);
        }
    }

    computed: {
        products() {
            return this.$store.getters.filteredProducts(200);
        }
    }

### 20.3 Асинхронные операции

Для локального хранилища можно синхронно работать. Для работы с сетью нужны асинхронные вызова. Мутации только синхронно. **actions**, добавляемые в конфигурацию хранилища, могут асинхронно.

Действия не меняют состояние непосредственно, вместо этого вызывают мутации. Первым параметром принимают контекст, через который имеют доступ к состоянию, геттерам и мутациям

    // store/index.js
    ...
    actions: {
        async getProductsAction(context) {
            (await Axios.get(url)).data.forEach(
                p => context.commit("saveProduct", p));
        },
        async deleteProductAction(context, product) {
            await Axios.delete(`${url}${product.id}`);
            context.commit("deleteProduct", product);
        }
    }

Вызываются через метод **dispatch()** на объекте хранилища. Первый параметр - строковое представление действия, остальные параметры опциональные, будут переданы в действие.

    // компонент
    ...
    computed: {
        products() { return this.$store.state.products; }
    }
    created() {
        this.$store.dispatch("getProductsAction");
    }


### 20.4 Подключение watch`еров

В хранилище можно хранить вспомогательные данные (напр. флаги). Для отслеживания их изменений подключаются watch`еры

Напр. добавляем свойство и мутацию в хранилище

    state: {
        selectedProduct: null
    },
    mutations: {
        selectProduct(currentState, product) { currentState.selectedProduct = product; }
    }

В компоненте можем изменять свойство через мутацию и подключить watch`ер

    // компонент
    ..
    created() {
        this.$store.watch(state => state.selectedProduct,
            (newValue, oldValue) => { ... })
    }

watch`ер принимает две функции. Первая определяет какое свойство отслеживать, вторая вызывается при изменении значения свойства.

### 20.5 Маппинги

Для упрощения кода. Набор функций, дающих доступ к свойствам хранилища: mapState, mapGetters, mapMutations, mapActions

    import {mapState, mapMutations, mapActions} from "vuex";
    ...
    computed: {
        ...mapState(["products"])
    },
    methods: {
        ...mapMutations({
            editProduct: "selectProduct",
            createNew: "selectProduct"
            }),
        ...mapActions({
            getProducts: "getProductAction"
            })
    },
    created() { this.getProducts(); }

Импортируются из модуля **vuex** и применяются через оператор `...`. Два варианта. Первый - в функцию передаем массив строковых имен свойств. Второй - передаем объект: свое имя для использования в компоненте - имя из хранилища или функция

### 20.6 Модули 

При усложнении кода хранилища можно рабивать на отдельные модули в отдельных файлах

Для этого создается объект со свойствами как в хранилище (state, mutations, actions и т. д.). 

Обычно модуль работает со своими внутренними свойствами. Если нужен доступ к общим свойствам хранилища - через доп. параметр (при этом еще обязательно параметр с "загрузкой") (см. `tableClass` в примере)

    // файл src/store/preferences.js
    export default {
        state: {
            stripedTable: true,
            primaryButton: false
        },
        getters: {
            editClass(state) {
                return state.primaryButton ? "btn-primary" : "btn-secondary";
            },
            tableClass(state, payload, rootState) {
                return rootState.products.length > 100 ? "table-stripped" : "";
            }
        }
    }

Для добавления модуля в хранилище: импортируем и настраиваем свойство **modules**. 

    import PresModule from "./preferences.js";
    
    export default new Vuex.Store({
        modules: {
            prefs: PrefsModule
        }
    })


Теперь компоненты могут использовать действия, геттеры и мутации из модуля точно так же как "родные".
Но для доступа с свойствам состояния **state** нужно обращаться через имя модуля из блока **modules**

    // компонент
    ...
    computed: {
        ... mapState({
            useStrippedTable: state => state.prefs.strippedTable
        })
    }

Можно настроить обращение к методам модуля через префикс области видимости. Тогда обращение к геттеру напр. будет как `<имя модуля>/<имя геттера>`

    // модуль
    export default {
        namespace: true,
        ...
    }

    // компонент
    ...
    сcomputed: {
        ...mapGetters: {
            tableClass: "prefs/tableClass"
        }
    }


## Ch 21. Динамические компоненты

### 21.1 Жизненный цикл

Динамические компоненты создаются / разрушаются каждый раз при отображении. Поэтому в методы типа `create()` не стоит помещать тяжёлую логику (напр. http запросы, инициализация хранилища). Такую логику нужно переносить в не динамические компоненты, напр. в основной компонент приложения

Другая опасность - **watch**. Для обычных компонентов достаточно добавить **watch**. Для динамических - неизвестно, когда он будет создан и не будет ли пропущено изменение отслеживаемого параметра. Поэтому при создании компонента нужно инициализировать первичное состояние (вызов функции на текущем значении отслеживаемой переменной). При отключении компонента - отключаться от отслеживания. (ф-я **watch** возвращает ф-ю, которая это и делает)

    <script>
    let unwatcher;
    export default {
        methods: {
            selectProduct(p) { // ф-я-обработчик изменения}
        },
        created() {
            unwatcher = this.$store.watch(state => state.selectedProduct,
                this.selectProduct);
            this.selectProduct(this.$store.state.selectedProduct); // иниц-я
        },
        beforeDestroy() {
            unwatcher();
        }
    }

### 21.2 Динамическое отображение

#### 21.2.1 Отображение через *is*
Для этого используется ключевое слово **is** в шаблоне. Обычно используется с тегом `component`. Значение тега - то, как зарегистрирован компонент в свойстве **components**

    <div class="row">
        <component is="ProductDisplay"></component>
    </div>

Можно динамически менять с помощью `v-bind:is=`

Компоненты создаются когда должны показываться и разрушаются, когда скрываются.Это можно переопределить через **`<keep-alive>`**. Тогда компонент не будет разрушаться, продолжит обрабатывать события в скрытом режиме. Предпочтительнее не использовать такое.

    ...
    <keep-alive>
        <component is=".."></component>
    </keep-alive>

#### 21.2.2 Пример навигации по приложению

Как компоненты управляют видимостью друг друга в зависимости от действий пользователя. Для больших расширяемых приложений шаблон

I. Отдельный модуль по навигации в хранилище добавляем со свойством и мутациями для этого свойства

    export default {
        namespace: true,
        state { selected: "table"},
        mutation: {
            selectComponent(state, selection) { state.selected = selection; }
        }
    }

II. Создаем вычисляемое свойство (на основе свойства из хранилища) и его используем в качестве значения **is**

    ...
    computed: {
        ...mapState({ selected: state => state.nav.selected}),
        selectedComponent() {
            return this.selected == "table" ? "ProductDisplay" : "ProductEdit"
        }
    }

III. На события пользователя (нажатия кнопок) вешаем мутации.

    ...
    methods: {
        ...mapMutations({
            selectComponent: "nav/selectComponent"
            }),
        editProduct(product) {
            ..
            this.selectComponent("editor");
        }
    }

IV. Также мутации вешаем на логику, вызывающую переключение компонентов

    ...
    methods: {
        async save() {
            await this.$store.dispatch("saveProductAction", this.product);
            this.$store.commit("nav/selectComponent", "table");
            this.product = {};
        }    


## Ch 22. URL Routing

### 22.1 Основы

Используется в сложных приложениях для отображения компонентов на основе url

#### 22.1.1 Конфигурирование

`npm install vue-router`

Обычно создается файл в `src/router`

Импортируются `Vue`, `VueRouter`; импортируются компноненты; подключаем `VueRouter`; создаем объект VueRouter и настраиваем пути в свойтве **routes**

    // src/router/index.js
    import Vue from "vue";
    import VueRouter from "vue-router";
    
    import ProductDisplay from "../components/ProductDisplay";
    import ProductEdit from "../components/ProductEdit";
    
    Vue.use(VueRouter);
    
    export default new VueRouter({
        routes: [
            {path: "/", component: ProductDisplay},
            {path: "/edit", component: ProductEdit}
        ]
    })


#### 22.1.2 Подключение конфигурации

    // main.js
    import router from "./router";
    new Vue({
        ...
        data:...,
        store,
        router,
        ...
    }).$mount('#app')

#### 22.1.3 Отображение компонентов через роутинг

    // главный компонент
    <template>
        ...
        <div>
            <router-view></router-view>
        </div>
    </template>
    <script>
        // ничего особенного не надо
    </script>

`VueRouter` заменяет элемент `router-view` на компонент, в соответствии с url. Причем к адресу автоматически добавляется `#`: `http://localhost:8080/#/`
`http://localhost:8080/#/edit`

#### 22.1.4 Навигация по URL

Для изменения url используются методы объекта `VueRouter`:

* `push(location)` - переход на указанный url
* `replace(location)` - то же самое, но без сохранения истории
* `back()` - на предыдущий url в истории
* `forward()` - на следующий url в истории

получить объект можно в любом компоненте, после того как подключили конфигурацию `this.$route`

    ...
    methods: {
        editProduct(product) {
            this.$router.push("/edit");
        }
    }

#### 22.1.5 Навигация через html-элементы

    
    ...
    <div>
        <router-link to="/" class="btn">Cancel</router-link>
    </div>

Такой элемент будет преобразован в тег `<a>`: `<a href="#/" class="btn router-link-active">Cancel</a>`. Отобразится в виде кнопки (css, bootstrap).

Такой способ подходит, когда достаточно просто перехода без доп. действий


### 22.2 Url Route Matching

#### 22.2.1 Работа через фрагменты

Пути проверяются на соответствие в том порядке, в котором они объявлены при конфигурировании в **routes**. При сравнении важна только часть url после `#` - фрагмент.

    http://localhost:8080/#/edit

 Стандартно браузеры использует фрагменты для навигации по статическому содержимому, Vue использует фрагменты, т.к. они позволяют обновлять страницу без отправки запросов. 

#### 22.2.2 Работа без фрагментов

При работе через фрагменты url может смущать пользователя. При ручном вводе обычного url (напр. `localhost:8080/edit` вместо `/#/edit`) будет переход на неизвестный адрес.
Можно настроить на работу с HTML5 History API. Новые браузеры это поддерживают, если с такой настройкой будет запущено на старом браузере - автоматически Vue переключится на фрагменты

    export default new VueRouter({
        mode: "history",
        routes: [...]
    })

**mode** принимает два значения: *hash* - по умолчанию (фрагменты), *history* - обычные адреса

#### 22.2.3 Перехват неверных адресов

Можно настроить сервер, чтобы для адрес для которых нет содержимого, возвращался `index.js`.

Другой вариант подключить редирект (путь `*` означает любой адрес)

    export default new VueRouter({
        routes: [
            {path: "/", component: ProductDisplay},
            {path: "*", redirect: "/"}
        ]
    })

#### 22.2.4 Псевдонимы для адресов

Позволяет несколько адресов указать на один компонент

    export default new VueRouter({
        routes: [
            {path: "/", component: ProductDisplay, alias: "/list"}
        ]
    })

#### 22.2.5 Получение данных о url в компонентах

Для этого используется свойство **$route** со следующими свойствами:

* *name* - возвращает имя для именованного пути
* *path* - часть url, path (напр. `/edit/4`)
* *params* - объект с параметрами url 
* *query* - объект с значениями параметров запроса (после `?`)

Напр. так

    ...
    methods: selectProduct() {
        if (this.$route.path == "/create") { ... }
    }

#### 22.2.6 Динамические пути

Позволяет работать с url типа `/edit/6`

I. В конфигурации указываем, что url состоит из нескольких сегментов через `:`

    ...
    {path: "/edit/:id", component: ProductEditor}

Первый сегмент используется для матчинга, все, что идет после будет присвоено свойству с именем `id`

II. Создаем разные ссылки в шаблоне напр. так:

    ...
    <router-link v-bind:to="'/edit/' + p.id">Edit</router-link>

III. Извлекаем и используем переменную сегмента после перехода по ссылке через `$route.params`

    ...
    let productId = this.$route.params.id;
    ...

#### 22.2.7 Использование регулярных выражений

Указываются в скобках после сегментов. Спецификаторы экранируются `\\`. 
Опциональные сегменты указываются через `?`
Примеры:

    {path: "/:op(create|edit)/:id(\\d+)"}
    {path: "/:op(create|edit)/:id(\\d+)?"}

#### 22.2.8 Именованные пути

Позволяют указыватб реальные ссылки только в конфигурации, а в остальных местах использовать псевдонимы. Но несколько усложняет синтаксис.

    {name: "table", path: "/", component: ProductDisplay},
    {name: "editor", path: "/edit/:id", component: ProductEditor},


Навигация теперь через объекты:
    
    <router-link v-bind:to="{name:'table'}">Cancel</router-link>
    ...
    this.$router.push({name: 'table'});

Для динамических сегментов нужно включать объект `params`

    ...
    <router-link v-bind:to="{name: 'editor', params: {op: 'edit', id: p.id}}">


### 22.3 Обработка изменения навигации

Когда меняется путь и изменяется компонент - старый уничтожается, новый создается. Когда путь меняется, но компонент используется тот же, уничтожение/создания не происходит, дополнительно вызывается метод жизненного цикла `beforeRouteUpdate()`

    beforeRouteUpdate(to, from, next) {
        this.selectProduct(to);
        next();
    }

Параметры `to`, `from` - это объекты *route* с новым путем и текущим. Параметр `next` - функция, определяющая поведению. Для перехода по новому пути просто вызываем. Функция `selectProduct()` извлекает из пути данные и обновляет компонент


## Ch 23. Особенности элементов роутинга

### 23.1 Работа с <router-link>

Имеет набор атрибутов, позволяющих настраивать внешний вид / поведение

#### 23.1.1 Выбор типа элемента

`<router-link>` по умолчанию преобразуется в элемент `<a>`. С помощью атрибута **tag** можно указывать другие элементы.

    ...
    <ol>
        <router-link tag="li" to="/list">List</router-link>    
        <router-link tag="li" to="/create">Create</router-link>    
    </ol>

#### 23.1.2 Выбор действия

Атрибут **event** определяет на какое действие реагирует элемент. По умолчанию - нажатие.

    <router-link event="mouseenter" to="">

#### 23.1.3 Стилизация элементов

Стили применяются уже к готовому шаблону, поэтому ссылаться на `router-link` не имеет смысла, в шаблоне не будет такого элемента

    <style scoped>
        router-link: {color: yellow;} // не имеет смысла
        li: { color: red;}
    </style>

##### 23.1.3.1 Реакция на текущий url

Когда url элемента `<router-link>` совпадает частично с текущим url страницы, элементу присваивается класс *router-link-active*, когда полностью еще и  - *router-link-exact-active*. Это можно использовать для стилизации текущего элемента. Эти классы устанавливаются при смене url.

    <style scoped>
        .router-link-active: {font-size: xx-large;}
        .router-link-exact-active: {font-weight: bolder;}
    </style>

Частичное соответствие можно отключить:

    <router-link to="..." exact>

##### 23.1.3.2 Изменение класса в зависимости от пути

Атрибуты **active-class** и **exact-active-class** используются, чтобы указать класс, который будет присвоен элементу при совпадении пути. Удобно при использовании с css-фреймворками

    <router-link to="" exact-active-class="btn-info" class="btn">


### 23.2 Вложенные пути

Для примера следующая структура приложения: от корня переход к продуктам или настройкам. От продуктов - к списку или к редактированию

`/products/list`
`/products/create`
`/products/edit/5`
`/preferences`

Должен быть компонент, соответствующий адресу `/products` и в шаблоне этого компонента должен присутствовать `<router-link>` для размещения компонента со списком или компонента для редактирования

Пути настраиваются так:

    ...
    routes: [
        {path: "/preferences", component: Preferences},
        {path: "/products", component: Products, 
            children: [
                {name: "table", path: "list", component: ProductDisplay},
                {name: "editor", path: "...", component: ProductEditor},
                {path: "", redirect: "list"}
            ]
        },
        {path: "/edit/:id", redirect: to => `/products/edit/${to.params.id}`},
        {path: "*", redirect: "/products/list"}
    ]


Когда есть свойство *children*, вышестоящий компонент имеет в шаблоне элемент `router-view`, а адреса потомков будут объединятся с адресом родителя для получения полного адреса (`/products/list` напр.)

`{path: "", redirect: "list"}` - редирект адресов, начинающихся с `/products`

`{path: "/edit/:id", redirect: to => '/products/edit/${to.params.id}'}` - для совместимости с прежней версией обрабатываем адреса типа `/edit/2` (дополнительно к `/products/edit/2`). Здесь в редирект функцию передаем. Параметр - объект *route*.

Именованные пути продолжат работать несмотря на изменение фактических url. В этом плюс именованных путей

### 23.3 Именованные элементы роутинга

Иногда в одном шаблоне нужно несколько элементов `router-link` для отображения разных дочерних компонентов. Для этого используется атрибут **name**

    ...
    <router-view name="left" />
    <router-view name="right" />

Теперь путь указывается так. Вместо свойства **component** - **components**, указывается объект: имя свойств - имена элементов `router-view`, значения - компоненты

    ...
    {path: "myUrl",
        components: {
            left: LeftComponent,
            right: RightComponent
    }}


## Ch 24. Расширенные возможности роутинга

### 24.1 Отдельные файлы для относительных путей

Создаем отдельные файлы (в папке `src/router` по соглашениям). В каждом файле группируем пути по каким-то признакам. В файле определяется или массив путей или один путь.

    // файл routes1.js с массивом путей
    ... // импорт компонентов
    export default [
        {path: "..", component: ...},
        {path: "..", component: ...}
    ]

    // файл routes2.js с одним путем
    ...
    export default {
        path: "...", component: ...
    }

Используем эти файлы в конфигурации. Массив из первого файла распаковываем через оператор `...`:

    import Routes1 from "./routes1";
    import Routes2 from "./routes2";
    ...
    export default new VueRouter({
        routes: [
            ...Routes1,
            Routes2
        ]
    })

### 24.2 Защита путей

Когда нужно предотвратить доступ по некоторым url (напр. это администратора, а не для обычного пользователя)

#### 24.2.1 Глобальная защита

##### 24.2.1.1 Создание глобалного защитника

Объект `VueRouter` имеет методы типа `beforeEach()`, `afterEach()`, `beforeResolve()`, которые вызываются в процессе навигации и через них можно управлять навигацией

    // файл src/router/index.js
    ...
    const router = new VueRouter({
        // стандартная настройка путей и др.
    });
    
    export default router;
    
    router.beforeEach( (to, from, next) => {
        if (to.path.startsWith("admin")) {
            next(false);
        } else {
            next();
        }
    });

Методы принимают функцию, которая имеет три параметра: 

* объект *route*, cooтветствующий новому url
* объект *route*, cooтветствующий исходному url
* функцию `next()`, управляющей дальнейшим поведением

Вызовы ф-и `next()`:

* `next()` - навигация на новый url происходит
* `next(false)` - навигация отменяется
* `next(string)` - редирект на новый url в виде строки
* `next(object)` - редирект на новый url в виде объекта (см. именованные пути)

##### 24.2.1.2 Редиректы

Можно использовать несколько защитных функций. В этом случае они будут применяться в том порядке, в котором определены.

Редирект можно делать на простой строковый url:

    ...
    router.beforeEach( (to, from, next) => {
        if (to.path == "..") {
            next("/products");
        } else {
            next();
        }
    })   

Когда выполняется редирект, происходит новый запрос и заново вызываются все функции защитники. Можно вызвать зацикливание.

Редирект через объект:

    router.beforeEach( (to, from, next) => {
        ...
            next({name: "editor", params: {op: "edit", id: 1});
        ...
    })

#### 24.2.2 Защита для конкретного пути

Используется метод `beforeEnter()`. Указывается как доп. свойство совместно с `path`, `component`. Можно применять для вложенных путей и для обычных

    {path: "..", component: ..., beforeEnter: (to, from, next) => {
        if (...) {
            next(false);
        } else { next(); }
    }}

#### 24.2.3 Порядок защитников 

Функции глобальных защитников выполняются первыми, потом функции защитников конкретного пути. Если глобальный защитник вызвал редирект, локальный защитник уже не будет вызван.

Есть функция `beforeResolve()` глобального защитника, но она вызывается после всех других функции, в том числе функций локальных защитников

#### 24.2.4 Защитники для компонентов

Методы жизненного цикла компонента:

* `beforeRouteEnter()` - новый путь подтвержден, но компонент еще не создавался, можно отменить переход или выполнить редирект
* `beforeRouteUpdate()` - когда путь, выбравший компонент меняется, и новый путь выбирает тот же компонент
* `beforeRouteLeave()` - перед тем, как меняется путь, который перед этим выбрал текущий компонент

Методы работают как и другие методы защитников с возможностью отмены, редиректа и т. п.

    export default {
        data: ...,
        methods: {...},
        beforeRouteLeave(to, from, next) {
            ...
        }
    }

##### 24.2.4.1 Доступ к компоненту в методе beforeRouteEnter

Этот метод вызывается до создания компонента. В методе-обработчике нельзя обращаться к методам или свойствам компонента через `this`. Можно реализовать через обратный вызов

    beforeRouteEnter(to, from, next) {
        next(component => component.someMethod());
    }

Здесь функция внутри `next()` будет вызвана позже, когда компонент будет создан 

### 24.3 Загрузка компонентов по требованию (ленивая)

В путях также можно использовать ленивую загрузку, как и при обычной загрузке. Но только базовые функции, без свойств `loading`, `delay` 

    const MyComponent = () => import("...");
    export default [
        {path: "...", component: MyComponent}
    ]


### 24.4 Независимые компоненты

Когда надо загружать компоненты через пути и нужны данные для компонентов, но эти данные через пути с параметрами передать нельзя (напр. это сторонние компоненты без поддержки работы с путями).

В таких случаях данные передаются через свойство **props** пути

    // компонент MsgCmp.vue
    ...
    export data {
        props: ["message"]
    }

    // файл роутера
    ...
    {path: "/hello", component: MsgCmp, props: {message: "Hello, Alice"}},
    {path: "/hello/:text", component: MsgCmp, 
        props: (route) => ({ message: `Hello, $(route.params.text)`}) },
    {path: "/message/:mesasge", component: MsgCmp, props: true}

Свойства можно указывать несколькими способами. В первом свойства независимы от пути и передаются в объекте. Во втором случае используется функция, принимающая объект *route* и формирующая на его основе объект со свойствами. Третий пример - **props** устанавливается в истину, при этом объект `$route.params` передается в компонент как есть 
