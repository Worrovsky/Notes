ch. 5 Классы

    5.1 Простые классы

        class Counter {
            private var value = 0
            def increment() {value += 1}
            def current() = value
        }

        использование:
            val counter = new Counter // или new Counter()
            myCounter.increment()
            println(counter.current)

        Заметки:
            классы по умолчанию общедоступные (public)
            в одном файле может быть несколько классов
            вызов метода без параметров: 
                myCounter.current // так
                myCounter.current() //или так
                соглашение:
                    скобки для методов-мутаторов, без скобок - методы, получающие значение из объекта
            можно объявить метод без скобок, тогда вызов метода обязателен без скобок
                ...
                def current = value

    5.2 Свойства с методами доступа

        при добавлении полей в класс, автоматически создаются методы чтения/записи
            для этих полей (поля с методами доступа - свойства)
        class P {
            var age = 0 // на уровне JVM - класс с приватным полем и геттером/сеттером
        }
        поле не объявлено как private, создается метод чтения с именем "age"
            и записи с именем "age_=":
        можно
            new P().age // чтение
            new P().age_=(42) // запись
        эти методы можно в любой момент переопределить
        если определен метод записи def foo_= ..., записать значение в свойство
            можно clazz.foo = ...

    5.3 Свойства только с методами чтения
        вариант А: объявить поле как val
            поле будет скрытым
            изменять его нельзя после создания (типа final)
            будет автоматически создан только метод чтения
        вариант Б: объявить поле private var и определить метод чтения

        итого способы реализации свойств:
            - var foo: синтез методов чтения и записи
            - val foo: синтез только метода чтения
            - приватное поле, определить методы чтения, записи
            - приватное поле, определить метод чтения

    5.4 Приватные поля объектов

        в Scala и Java по умолчанию метод имеет доступ к приватным полям в любых объектах
            своего класса (не только в своем объекте)

            class Counter {
                private var value = 0
                def foo(other: Counter) {
                    other.value ... // доступно приватное поле другого объекта
                }
            }

        можно запретить, объявив переменную как private[this]:
            class Counter {
                private[this] var value = 0 // теперь other.value недопустимо
            }
        такой режим называется приватным для объекта
        если переменная private генерируются приватные методы доступа
        если private[this] - методы доступа не генерируются вовсе
        можно дать доступ определенному классу к приватному полю, 
            объявив его как private[ClassName] (на уровне JVM будут созданы
            методы с особыми именами)
        все эти способы редко применяются

    5.5 JavaBeans

        если нужно сформировать методы по соглашению JavaBeans (getXxx/setXxx)
            используется аннотация @BeanProperty
        создаются дополнительно к методам xxx / xxx_=

        import scala.reflect.BeanProperty
        class P {
            @BeanProperty var age = 0
        }
        для var будут созданы get, set
        для val - только get
        для private не имеет смысла

    5.6 Дополнительные конструкторы

        класс имеет один главный конструктор и любое количество дополнительных
        дополнительные конструкторы:
            - имеют имя this
            - каждый дополнительный конструктор начинается с вызова конструктора 
                выше или главного конструктора

        class Foo{
            private var age = 0
            private var name = ""
            def this(n: String) {
                this() // вызов главного конструктора
                this.name = n
            }
            def this(name: String, age: Int) {
                this(name)  // вызов доп. конструктора выше
                this.age = age
            }
        }

        создать объект можно через вызов главного конструктора или любого дополнительного

    5.7 Главный конструктор

        каждый класс имеет главный конструктор

        class Person(val name: String, val age: Int) {
            println("this is part of main constructor") // часть определения класса, часть главного конструктора
        }

        задается сразу в определении класса:
            1) параметры главного конструктора перечисляются сразу за именем
            2) главный конструктор выполняет все инструкции в определении класса

        заметки:
            - отсутствие параметров означает пустой главный конструктор 
                (просто выполнит инструкции в теле класса)
            - у параметров главного конструктора можно указывать значения по умолчанию
                class Person(val name: String = "<empty>" ...)
            - параметры могут объявляться в любой допустимой комбинации val/var/private/private[this]/@BeanProperty
            - параметры могут быть без указания var/val тогда:
                а) если параметр используется внутри методов, это эквивалентно private[this] val,
                    создаются методы
                b) если параметр не используется в других методах - поле не создается
            - главный конструктор может быть private, тогда создание объекта - только через дополнительные
                class Person private (name: String ...)

    5.8 Вложенные классы

        вкладывать можно все что угодно и куда угодно
            class Foo {
                class Bar { ... }
                innerClass = new Bar()
            }


        создать внутренний класс можно из любого места через экземпляр внешнего:
            val foo = new Foo()
            val inner = new foo.Bar() // или просто new foo.Bar
            (ср. Java: foo.new Bar())

        каждый экземпляр внешнего класса имеет собственный внутренний класс:
            var inner = new foo1.Bar
            inner = new foo2.Bar // ошибка компиляции: несоответствие типов: ожидается foo1.Bar, получено foo2.Bar

ch. 6 Объекты

    6.1 Объекты-одиночки

        в Scala нет статических методов и полей
        аналог синглтона - object
            object Foo {
                def bar() = {..}
            }
        существует в единственном экземпляре
        конструктор объекта вызывается при первом обращении к нему
        вызов:
            Foo.bar()
        аналог класса
            может наследовать другие классы
            может реализовывать трейты
            но не может иметь конструкторов с параметрами

    6.2 Объекты-компаньоны

        аналог статических методов класса
        определение объекта с тем же именем, что и у класса в том же файле, где и класс
            class Foo {
                val a = Foo.bar() // вызов метода объекта-компаньона
            }
            object Foo {
                def bar(): Int = 6
            }
        класс и его компаньон могут обращаться к приватным полям и методам друг друга
        хотя и связан с классом, но вызов методов идет через имя объекта, как у обычного
            Foo.bar()
        если объект определен с именем, отличным от имени класса, доступа к приватным
            членам у класса не будет

    6.3 Объекты, расширяющие классы или трейты

        abstract class BaseClass {
            def do(): Unit
        } 
        object ImplBaseClass extends BaseClass {
            override def do() = {..}
        }

    6.4 Метод apply

        часто применяется в объектах
        если определен apply, тогда можно вызывать Object(...)

        object Foo {
            def apply() = 5
        }
        val a = Foo() // можем, т.к. определен метод apply

        часто применяется для создания экземпляра класса-компаньона:
            class Foo (val name: String){
                ...
            }
            object Foo {
                def apply(n: String) = new Foo(n)
            }
            теперь создавать экземпляр можно Foo("a") или new Foo("a")

    6.5 Объект, представляющий приложение
        
        точка входа в программу - функция с сигнатурой Array[String] => Unit
            object Hello {
                def main(args: Array[String]) {
                    println("Hello")
                }
            }

        или можно унаследовать трейт App, а код поместить в тело конструктора
        доступ к args также будет
            object Hello extends App {
                println(args[0])
            }

    6.6 Перечисления

        Перечислений как типа нет в Scala
        используется вспомогательный класс Enumeration из стандартной библиотеки:
            создать объект
            унаследовать Enumeration
            инициализировать значения вызовом метода Value

            object Enum extends Enumeration {
                val Red, Green, Blue = Value // аналог val Red = Value; val Blue = Value ...
            }
        Value - объект-компаньон вложенного класса
            можно с именем и/или числовым значением: Value(0, "Red"), Value(3)
            по умолчанию числовое значение - +1 от предыдущего
                строковое - имя поля

        Обращение к элементам теперь как Enum.Red, Enum.Green
        тип значения перечисления: Enum.Value, не Enum

        у значений есть методы id - возвращает числовое значение
                            toString - строковое

