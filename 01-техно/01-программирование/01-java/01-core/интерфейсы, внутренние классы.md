
Интерфейс
    
    общее
        указание на то, что может делать класс без реализации
        класс может реализовывать интерфейс(ы)

        пример: интерфейс Comparable
            public interface Comparable {
                int compareTo(Object other);
            }

        можно с указанием типов
             public interface Comparable <T>  {
                int compareTo(T other);
            }
            тогда например класс может реализовывать Comparable <int> и должен 
                определить метод 
                int compareTo(int other)

        кроме методов можно константы объявлять
        методы в интерфейсе по умолчанию - public, можно не указывать, но в классе обязательно public
        создавать объекты с типом интерфейса нельзя

    реализация в классе:
        1. объявить что класс реализует
            public class A implements MyInterface {...}
        2. реализовать все методы интерфейса

    свойства интерфейса
        не класс, нельзя с помощью new создавать
            x = new Combarable(); // error
        но можно переменную объявлять
            Combarable x; // переменная может ссылаться на объект класса, реализующего интерфейс
            x = new A(); 
        оператор instanceof проверяет, реализует ли класс интерфейс
        интерфейсы могут наследовать друг друга

        можно константы объявлять
            по умолчанию public static final
            интерфейс может состоять из одних констант, без методов. Класс, реализующий
                этот интерфейс имеет доступ к константам  напрямую 
        класс может реализовывать несколько интерфейсов (перечисляются через зпт)

        интерфейсы как замена множественному наследыванию

    копирование vs клонирование
        копирование простых немутабельных типов:
            int a = 3;
            int b = 4;
            b = a; 
            a = 5; // b по прежнему = 4
        копирование изменяемых типов:
            Employee a = new Employee(100);
            Employee b = a;  // здесь ссылка присваивается
            b.raiseSalary(20); // a также изменяется
        клонирование:
            метод clone() класса Object
            создается новый объект и возвращается ссылка на него
                при этом копируются все поля объекта
                именно копируются, ссылочные объекты - ссылками
                поверхностное клонирование
        глубокое копирование:
            интерфейс CLoneable - интерфейс-маркер(нет методов, 
                    может использоваться для проверки типа)
            переопределить метод clone():
            обработка исключения
                public class Employee implements CLoneable{
                    public Employee clone() throws CloneNotSupportException {
                        Employee cloned = (Employee) super.clone();
                        cloned.field = field.clone();
                        return cloned
                    }
                }
            проблема при клонировании подклассов:
                если в подклассе не переопределить метод clone(),
                новые поля подкласса не будут клонированы, а скопированы

    интерфейсы и обратный вызов
        на примере класса javax.swing.Timer
        конструктор: Timer(int interval, ActionListener listener)
            здесь ActionListener - интерфейс с методом 
                public void actionPerformed (ActionEvent event){}

        создаем класс-обработчик
            Class TimerPrinter implements ActionListener{
                public void actionPerformed(ActionEvent event){
                    // ...
                }
            }
        создаем таймер
            ActionListener listener = new TimerPrinter();
            Timer myT = new Timer(10, listener);


Внутренние классы

    класс, объявленный внутри другого класса
    напр. 
        class Task{
            //...
            private class TimerPrinter implements ActionListener {
                    
            }
        }
    при этом не означает, что экземпляр основного класса содержит поле типа внутреннего класса
    
    внутренние классы могут быть закрытыми, в отличие от обычных классов (public или в пределах пакета)

    объекты внутреннего класса имеют доступ к полям внешнего
       по сути компилятором создается ссылка на внешний класс в конструкторе:
            public TimerPrinter(Task task){
                outer = task;
            }
        и дальше доступ к полям внешнего класса - через эту ссылку неявно

    Взаимодействие внешнего/внутреннего:
        обращение к полям/методам внешнего из внутреннего
            <ИмяВнешнего>.this.<ИмяПоля>
        во внешнем создать объект внутреннего
            this.new <ИмяВнутреннего> ()
        если внутренний не закрыт можно создавать в других классах
            <ИмяВнешнего>.this.new <ИмяВнутреннего>
        или просто обращаться
            <ИмяВнешнего>.<ИмяВнутреннего>

    компилятор/JVM и внутренние классы:
        вирт. машина ничего не знает о внутренних классах, не умеет их обрабатывать
        на этапе компиляции внутр. классы преобразуются в обычные
        добавляются нужные поля на ссылки, методы доступа и т.п.

    анонимные внутренние классы
        когда объект создается один раз, имя не обязательно
        синтаксис:
            new <СуперТип> (<параметры для создания объекта>){
                <методы и поля класса>
            }
            СуперТип - класс, который расширяет анонимный класс 
                или интерфейс, который реализует
            параметры передаются в контруктор СуперКласса

            пример:
                ActionListener listener = new ActionListener(){
                    public void actionPerformed(ActionEvent e){

                    }
                });

    статические внутренние классы
        public static class StatClass{..}        
        не содержит ссылки на создавшие его внешний класс



