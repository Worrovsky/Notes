Универсальные типы
    
    зачем:
        - работа с объектами разных типов
        есть вариант через Object, но
            - приведение типов нужно
            - можно разные типы, нет проверки на используемый тип, ошибка не видна до момента выполнения

        ArrayList <String> array = new ArrayList<String>();
        здесь уже нельзя поместить не String в массив
        и не нужно приведение типов, компилятор знает тип элементов

    создание универсального класса:
        public class Pair <T>{

            public Pair(T first, T second){
                this.first = first;
                this.second = second;
            }

            private T first;
            private T second;
        }
        в классе указывается переменная (может несколько, напр. <T, U>), 
            которая обозначает тип, 
            и этот тип может быть типом переменных, параметров, возвращаемых значений и т. п.

        При использовании класса - указывается конкретный тип: универсальный класс - как фабрика классов

    Универсальные методы:
        можно в составе обычных классов объявлять

        public class SomeClass{
            public static <T> T getMax( T[] array ){...}
        }
        вызов:
        String r = SomeClass.<String>getMax(a);
        часто можно вызывать без указания типа, компилятор млжет определить тип

    Ограничение типов:
        можно ограничить тип, например указать интерфейс или базовый класс
        public static <T extends Comparable> ...
        несколько ограничений:
            <T extends Comparable & Seriazible>
        классов в ограничениях - не более одного (см. наследование)
        если в ограничениях класс - должен быть первым

Параметры типы - классы или интерфейсы

можно объявлять сокращенно:
    ArrayList<String> = new ArrayList<>();

Универсальные типы и JVM
    
    ВМ не поддерживает УТ
    на этапе компиляции УТ заменяются обычными методами/классами и т.п:
        параметры типа удаляются
        переменые типа заменяются ограничивающими типами или
            если не указаны ограничения - классом Object
        при этом если создавать классы разных типов - разрастания не будет,
            напр. есть Pair<String> и Pair<Integer>, будет создан один класс 
            с заменой на тип Object
        если есть несколько ограничений - тип подставляется первый, 
            остальные - преобразование типов по необходимости
            поэтому следить за порядком ограничивающих типов: маркеры - в конец

    универсальные выражения:
        также замена при компиляции
        - типы на Object
        - приведение типа после получения
        напр. 
            Pair <Employee> b = ...;
            Employee f = b.getFirst(); // возвращает Object, затем приведение

    Ограничения при работе с УТ  (следствие преобразования в низкоуровневый код)
        - не поддерживаются простые типы int, boolean
            замена на Object, простые типы - не Object
        
        - проверка/приведение типа, получение класса для УТ
            параметры типа никак не анализируются (все равно - Object)
            поэтому 
                instanceof Pair<String>, instanceof Pair<Integer>, instanceof Pair не различаются
                getClass() одинаковый результат дает: Pair.class

        - массивы с параметрами типов нельзя
            Pair <String>[] a; // ошибка

        - экземпляры УТ нельзя создавать
            напр. конструктор в унив. классе:
                public Pair(){first = new T();} // ошибка, new Object() недопустимо

        - в статических полях/методах переменные типа недопустимы

        - конфликты в результате приведения:
            создание пользовательских методов с такой же сигнатурой как методы Object
            использование ограничивающих типов с одинаковыми методами

        - УТ и наследование
            Pair<T> и Pair<S> никак не связаны, даже если T и S связаны
                напр. Employee суперкласс для Manager
                Pair<Employee> eml; 
                eml = new Pair<Manager>(...); // неправильно

        - подстановочные типы
            означает любой тип, расширяющий указанный (т.е. подкласс для суперкласса)
                Pair<? extends Employee>
            или наоборот - основание для уазанного
                Pair<? super Manager>




