Общие вопросы
    
    ст. 45 Сводите к минимуму области видимости локальных переменных
        + удобство чтения
        + уменьшение вероятности ошибок

        Сужение области видимости:
            - объвление переменной непосредственно перед ее использованием
            - использование циклов for вместо while (for инкапсулирует автоматом переменные цикла,
                    ср. int i = 0;
                        while (i<10) {...}
                        // всё ещё видна i после цикла)
            - использование небольших четко позиционированных методов

    ст. 46 Предпочитайте цикл for each
        условия:    
            c 1.5, объект должен реализовывать Iterable
        
        + более простая и ясная конструкция
        + удобен для вложенных циклов (через for цикл c next() придется сохранять промежуточные значения)
        + немного лучше производительность (однократный просчет ограничений индексов)

    ст. 48 Если нужны точные ответы не используйте float и double

        реализуют бинарную арифметику с плавающей точкой (для научных, инженерных расчетов)
        не подходят для денежных расчетов
            нельзя представить число 0.1

        для денежных расчетов нужно использовать BigDecimal или  int, long (самостоятельно отслеживать десятичную точку)

    ст. 49 Предпочитайте обычные примитивные типы, а не упакованные

        различия между обычными и упакованными:
            - обычные имеют только значение, упакованные еще и идентичность (могжет быть 2 упакованных с 
                одним значением, но разными идентичностями)
            - упакованные кроме функциональных значений имеют и нефункциональное null
            - обычные примитивные более эффективны

            нельзя сравнивать упакованные через == (сравнивается идентичность, не значения)

            когда в операции участвует примитивный и упакованне типы (напр. i == i_box), 
                происходит автораспаковка, если значение упакованного = null (неявно инициализируются
                упакованные в null), получаем NullPointerException

            в циклах упаковка/распаковка снижает производительность
                Long sum = 0;
                for (int i=0; i<10000; i++) {
                    sum = sum + i; // здесь авто упаковка
                }

    ст. 51 При конкатенации опасайтесь потери производительности

        время конкатенации n строк через оператор "+" О(n^2)
        поэтому при большом количестве строк нужно применять StringBuilder


