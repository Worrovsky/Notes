# The Art of Multiprocessor Programming

## Ch. 1. Introduction

### 1.1 Shared Objects and Synchronization

* Есть задача (напр. найти все простые в числа в заданном диапазоне), нужно распараллелить
* как разделить между потоками?
* просто разделить входные данные поровну (диапазоны разделить) не всегда подходит (количество данных != количеству работы)(проверять большие числа сложнее)
* выгоднее давать потоку по одному числу, после проверки давать следующее
* здесь необходим разделяемый счетчик с методом getAndIncrement()
* простейшая реализация типа `return counter++;` не будет работать в многопоточной
* выход: 
    - использовать аппаратные реализации атомарных операций read-modify-write
    - программные реализации
* такое выполнение блока кода только одним потоком в любой момент времени - **взаимное исключение** (mutual exclusion) 

### 1.2 Fable

* Алиса и Боб имеют общий двор. На нем нужно выпускать кошку/собаку, не допуская одновременного присутствия
* Протокол через флаги:
    - поднимает флаг
    - смотрит на соседний
        + если опущен - занимает двор. После - опускает флаг, освобождая двор
        + если поднят - опускает свой (двор занят)
* формально нужно доказать, что взаимное исключение работает. Допустим Алиса и Боб одновременно решают поднять флаг. Алиса поднимает свой и только после этого смотрит на соседний. Если Боб еще не поднял свой, Алиса занимает двор. При этом когда Боб поднимет свой, он увидет поднятый флаг Алисы и никак иначе. 
* В этом протоколе не важны длительности процессов поднятия, опускания, осмотра, а важно только когда они закончились (мгновенные действия)

#### Свойства многопоточного протокола

* **взаимное исключение** - только один поток имеет доступ к ресурсу в момент времени
* **deadlock-freedom** - если ресурс свободен и поток хочет доступ - он получает, если одновременно несколько поток хотят доступ - хотя бы один получит
* **starvation-freedom** (оно же lockout-freedom) (starvation-истощение) - не будет ли один поток снова и снова занимать ресурс, не давая другим потокам доступ. Флагами это не гарантируется
* **waiting** - если один поток занял ресурс и с потоком что-то случилось, будет ли гарантирован доступ к ресурсу
* **fault-tolerance** - отказоустойчивость

### 1.3 Producer-consumer problem

* Алиса владеет животными. Боб обязан их кормить. Животные не любят Боба. Боб должен выгружать еду во двор, когда там нет животных и не осталось еды. Алиса не должна выпускать животных, когда во дворе нет еды.
* Протокол **can-and-string** (банки и веревки)
    - Боб (producer)
        + помещает банку на подоконник Алисы и привязывает к ней веревку до своего окна
        + размещает еду во дворе
        + сдергивает банку
        + ждет, когда Алиса заново поставит банку
    - Алиса (consumer)
        + ждет пока банка будет сброшена
        + выпускает животных
        + когда животные вернулись и еда закончилась - устанавливает банку
* Свойства:
    - mutual exclusion - животные и Боб не встречаются
    - starvation-freedom - если Боб готов поставлять еду, животные будут ее потреблять
    - Producer-consumer - Боб не будет поставляет еду, пока она есть; животные не выйдут во двор если нет еды
* Основное отличие от mutual exclusion - в Producer-consumer участвуют обязательно две стороны. В mutual exclusion - один поток может раз за разом занимать ресурс
* Также подвержен waiting

### 1.4 Readers-writers

* Алиса и Боб решают обмениваться сообщениями. Боб выкладывает сообщение по букве за раз на стене. Алиса просматривает сообщения в подзорную трубу по букве за раз. Есть проблема, что Алиса может видеть части от разных сообщений
* Здесь можно использовать mutual exclusion (но есть вероятность пропуска сообщения)
* Или протокол Producer-consumer, где Боб производит сообщения, Алиса потребляет
* Эти решения подразумевают ожидание
* Есть вариант без

### Реальная выгода параллелизации

* В идеале увеличение количества процессоров в n раз приведет к увеличение производительности в n раз.
* Пример: 5 одинаковых комнат надо покрасить. Наняв 5 рабочих, в  5 раз увеличим скорость. Но если одна комната в 2 раза больше других - общий прирост не будет 5-тикратным
* Ускорение работы ограничено тем, сколько работы должно быть выполнено последовательно и на накладные работы по сведению результатов
* Закон Амдала: S = 1 / (1 - p + p/n)
    - S - ускорение от выполнения на нескольких процессорах
    - n - количество процессоров
    - p - доля работ, которая может быть выполнена параллельно
* тогда (полагая время работы на одном процессоре = 1)
    - (1-p) - время не распараллеливаемое
    - p/n - время за которое выполняется распараллеливаемая часть
    - 1-p + p/n - общее время
* напр. если 90% можно параллелить, тогда при n=4 S=3, при n = 10, S=5
* Нужно стремиться уменьшать накладные расходы (уменьшать синхронизируемые / блокируемые уастки кода)

## Ch. 2 Mutual Exclusion

### Critical sections

* Прблемы чтения/записи одного значения несколькими потоками решается **critical section** - блоком кода, который может быть выполнен только одним потоком в любой момент времени (оно же mutual exclusion)
* стандартный способ - через объeкт Lock()

    public interface Lock{
        public void lock();
        public void unlock();
    }
* поток устанавливает блокировку, когда вызывает метод `lock()` и снимает блокировку, когда вызывает метод `unlock()`
* формат использования:
    - каждая критическая секция должна быть связана с уникальным объектом Lock
    - поток вызывает метод `lock()` перед входом в критическую секцию
    - поток вызывает метод `unlock()` после выхода их крит. секции
* необходимо использовать блок try-finally:
    mutex.lock();
    try {
        ...
    } finally {
        mutex.unlock();
    }
* Свойства, которым должен удовлетворять хороший Lock-алгоритм
    - mutual exclusion: критические секции разных потоков не пересекаются
    - deadlock-freedom: если какой-либо поток пытается установить блокировку, тогда хоть какой-нибудь поток сможет ее установить(может другой). Если поток А вызвал lock(), но не установил блокировку, другие потоки могут выполнять крит. секции
    - starvation-freedom: каждый поток, пытающийся получить блокировку - получает. Каждый вызов lock() возвращается (завершается). Т. е. потоки не крутятся бесконечно, пытаясь забокировать
* deadlock-freedom объекта Lock не означает того же для всей системы: поток А установил блокировку x, поток Б - y. Затем А хочет заблокировать y, а Б - х. Будут ждать друг друга.
* starvation-freedom - наименее слабое свойство. Есть алгоритмы без такого свойства. + желательно иметь какие-либо гарантии как долго может поток ждать 

### Примеры алгоритмов (нерабочие) на 2 потока


    class LockOne implements Lock {
        private boolean[] flag = new boolean[2];
        public void lock() {
            int i = ThreadID.get(); // потоки имеют индексы 0 или 1
            int j = 1- i;
            flag[i] = true;
            while (flag[j]) {}
        }
        public void unlcok() {
            int i = ThreadID.get();
            flag[i] = false;
        }
    }

* 1-й вариант обеспечивает mutual exclusion, но подвержен deadlock, когда А-write(flag[A]=true) и B-write(flag[B]=true) перед А-read(flag[B]) и B-read(flag[A]), т. е. когда потоки перекрываются 

2-й вариант

    class LockTwo implements Lock {
        private volatile int = victim;
        public void lock() {
            int i = ThreadID.get(); // потоки имеют индексы 0 или 1
            victim = i;
            while (victim == i) {}
        }
        public void unlcok() {}
    }

* Обеспечивает ME,  но подвержен deadlock, когда единственный поток запрашивает блокировку (потоки не пересекаются).
* Нормальный алгоритм можно построить на комбинацци этих двух

#### Алгоритм Петерсона

    class Peterson implements Lock {
        private volatile boolean[] flag = new boolean[2];
        private volatile int victim;
        public void lock() {
            int i = ThreadID.get(); // потоки имеют индексы 0 или 1
            int j = 1 - i;
            flag[i] = true;                 // i'm interested
            victim = i;                     // you go first
            while (flag[j] && victim==i) {} // wait
        }
        public void unlcok() {
            int i = ThreadID.get();
            flag[i] = false;                // i'm not interested
        }
    }

* Алгоритм Петерсона - starvation-freedom и deadlock-freedom