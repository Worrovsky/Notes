## ch. 2 Основные принципы

### Тестировать реальное приложение

3 категории кода для тестирования

#### Микробенчмарки
небольшой участок кода
напр. один алгоритм, одна функция

Проблемы:
	компилятор может упрощать код, выбрасывая неиспользуемые переменные, циклы: поэтому всегда использовать переменные (запись и чтение)

если необходимо сравнить 2 реализации какого-либо алгоритма нужен набор данных
(напр. набор случайных значений)
их формировать заранее, чтобы не включать в общее время теста

бенчмарк должен использовать свои результаты
бенчмарк не должен включать сторонние операции (напр. подготовку данных)
бенчмарк должен проверять входные параметры
нужен warmup

в общем случае микробечмарк сложно

#### Макробенчмарки

приложение в совокупности своих частей
тогда видны узкие места
	
#### Месобенчмарки

что-то между микро и макро
уже не одна функция, но еще не в полном приложении
какой-то связанный набор операций

### Смотри на производительность с разных сторон, выбирай что важно для конкретного приложения

#### Elapsed time (batch)

как долго выполняется конкретная операция
в простом случае: запустил - измерил
для Java c just-in-time компиляцией - сложнее, нужно время на выход в рабочий режим (warm-up)
плюс много вещей может кешироваться: данные из БД, файлы и другое
с другой стороны иногда важно все время работы от старта до окончания, 
	напр. сервис запускается, обрабатывает набор запросов и не важно
	что первую половину он обрабатывал дольше чем вторую

#### Throughput (пропускная способность)

количество работы за промежуток времени
для системы клиент-сервер (в общем смысле) клиент безостановочно
	отправляет запросы на обработку и подсчитывает обработанные
измеряется в:
 	транзакции в секунду (TPS)
	запросы в секунду  (RPS)
	операции в секунду (OPS)

#### Responce time

время от отправки запроса на сервер до получения ответа
иногда включают **think time** (эмуляция работы клиента/пользователя)
измеряют либо по среднему, либо в процентилях (снижают влияние пиков, GC?)


### Изменчивость тестов

на тест влияет окружение (загруженность сети, локальной машины и т. п.),
	входные данные (как правило тесты должны быть на случайных данных).
Это ведет к изменчивости результатов от запуска к запуску.
Проблема: результаты двух тестов - это значимое изменение или колебание из-за внешних факторов

Подход: выполнять тест много раз и сравнивать средний результат
но это все равно не дает гарантии
нужен стат. анализ (t-test, Стюдент)

### Тестируй рано, тестируй часто

попытка: тесты производительности как часть этапа разработки

основные принципы:
	* автоматизация (скрипты, вычисление результатов)
	* измерение всего (загрузка ресурсов системы и т.п.)
	* запуск на целевой платформе



## ch. 3. Инструменты измерения производительности

### Средства операционной системы

обычно это измерение загрузки процессора, памяти, дисков, сетевая нагрузка

#### Загрузка процессора

* процессорное время делится на пользовательское и системное (вызов системных команд)
* приложения используют системное время когда обращаются к диску, сети и т.п.
* цель оптимизации: максимизировать использование ЦПУ при минимизации времени использования

Заметки по параметру **использование процессора**:
* всегда среднее за интервал (1 сек, 5 сек, ...)
* так напр. использование процессора для некой программы = 50% за 10 мин.
	- увеличив использование до 100%, мы удвоим производительность и сократим время работы до 5 мин.
	- еще удвоив производительность, сократим время до 2,5 мин (выше 100% использовать не сможем)

напр. vmstat (Linux) выводит сведения об использовании процессора за 1 сек:
	`------ cpu -------`
	`us  sy   id   wa  `
	`41  3    56   0   `  us - пользовательсое, sy - системное, id - простои

Причины простоев:
* приложение блокировано (синхронизация)
* приложение ожидает ответа от БД напр.
* приложению нечего делать

Первые две позиции - цели для оптимизации

Использование одного процессора для приложения с однократной задачей:
* максимизируем загруженность
Использование одного процессора для приложения по многократной обработке (сервер):
* минимизируем время использования (снижаем загруженность) -> увеличиваем количество обрабатываемых запросов
Для многопроцессорных систем - все то же самое, плюс дополнительно просмотр очереди потоков: не допускать увеличения очереди (простои) из-за ограничения размера пула потоков

Просмотр очереди потоков:
* Linux
	- `vmstat`
	- показывает количество активных потоков (run queue)	
	- всегда больше 0
	- нужно стремиться к количеству ядер или меньше
* Windows
	- `typepref -si 1 "\System\Processor Queue Length"`
	- показывает ожидающие потоки, исключая активные (processor queue)
	- может быть 0
	- стремиться к 0 (нет очереди, обрабатываются сразу)

#### Загрузка дискового пространства

* проверка: не является ли диски узким местом, если приложение активно работает с дисковым пространством
* что можно смотреть:
	- загрузка процессора (systme usage) на выполнение ввода/вывода
	- процент использования дисков
	- количество свапов виртуальной памяти

### Средства JDK

#### Основная информация о JVM










