ch 2. Операторы и выражения

    Операторы
        
        Общее
            операторы - спец. символы, применяемые к набору переменных, значений, литералов 

            Приоритет:
                - пост-унарные: i++, i-- и пре-унарные: --i, ++i
                - унарные: +, -, !
                - умножение, деление, модуль: *, /, %
                - сложение, вычитание
                - сдвиг: <<, >>
                - отношение: <, >, <=, instanseof
                - равенство, неравенство
                - логические битовые: &, |, ^
                - логические: &&, ||
                - тернарный
                - присваивание: =, +=,  и т. п.

        Numeric Promotion
            1. если два операнда имеют разные типы, одно из них преобразуется 
                к большему типу
            2. если один операнд - целочисленный, а второй - с плавающей точкой,
                целочисленный преобразуется в тип с плавающей точкой
            3. маленькие типы (byte, short, char) всегда преобразуются в int
                в бинарных арифметических операциях, даже если нет операнда 
                типа int
            4. после всех преобразований тип результата будет равен типу операндов

            Примеры:
                short + short -> int (п. 3)
                ++short -> short (не п. 3, не бинарная операция)
                int * long -> long
                short * float / double -> double

        Унарные операции
            + указание, что число положительное (и так по умолчанию)
            - инвертирует знак переменной числового типа (boolean не применяется)
            ! инвертирует переменную типа boolean (с числовыми не работает) 

            !0; -false // не компилируется

        Инкремент / декремент
            высший приоритет среди арифметических
            пре-инкремент ++i : сначала вычисляется и новое значение передается в выражение
            пост-инкремент i++ : значение передается в выражение, затем вычисляется

        Присваивание
            автоматически приводит от меньших типов справа к большему типу слева
                long k = 56;
                double d = 4.5f;
            наоборот - ошибка компиляции
                short t = 2 * 2;

        Casting (примитивных)
            можно от больших типов к меньшим; от дробных к целочисленным
                int x = (int) 1.0;
            при этом - потеря значений;

        Составные операторы присваивания
            +=, -=, *=
            x += 2; эквивалент x = x + 2;

            автоматически приводят тип:
                long x = 5;
                int y = 1;
                y = y * x; // ошибка компиляции, исправить y = (int) y * x;
                y *= x; // допустимо: у в long переводится, перемножение, затем результат в int
            результат выражения присваивания равен выражению справа:
                int y;
                int x;
                x = (y = 3); // x=3 и y=3    

        Логические выражения
            & (и), | (или), ^ (исключающее или)
            применяются для boolean и числовых тип (битовые операции)
            операции по короткой схеме &&, ||:
                И, ИЛИ, но если левый операнд однозначно задает результат, правая часть не выполняется

        Операторы сравнение на равенство
            различать:
                объекты те же самые
                объекты эквивалентны
            для булевых и числовых это одно и то же
            Для операторов ==, != только 3 сценария:
                - сравнение 2-х числовых переменных (действует те же правила приведения типов)
                - сравнение 2-х булевых переменных
                - сравнение 2-х объектных переменных, в т. ч. null, String
            все остальные комбинации - ошибка компиляции:
                boolean t = 6 == false;

            Ссылочные типы равны:
                - если они указывают на один и тот же объект (строки !!)
                - оба равны null 


    Выражения

        if-then
            обязательность скобок if (...) ...
        if-then-else

        тернарный оператор
            bool ? expression : expression;
            expression - любое выражение, возвращающее значение
            оба выражения не обязательно одного типа
                System.out.println(y < 4 ? 5 : "more"); // compile (print() конвертирует в строки)
            но при присваивании должны быть одинакового типа
                int x = y < 4 ? 5 : "more"; // does not compile
            вычисление по короткой схеме: только одно выражение будет вычислятся

        switch

            switch (var) {
                case constExp1: 
                    ...
                    break; // optional
                ...
                default:   // позиция блока default не важна
                    ...
            }

            Поддерживаемые типы:
                - int, byte, short, char и их обертки
                - String
                - enum

                boolean, long НЕ поддерживаются

            Ограничение на значения в блоке case:
                должны быть константами времени компиляции
                    т.е. литералы, перечисления-константы, final константа
                того же типа, что выражение в блоке switch

            Особенности default и break:
                - default может находиться в любой позиции, не обязательно в конце
                - отсутствие break: при выполнении условия, будет выполнен блок 
                    в текущем блоке case, и во всех последующих (игнорируя проверку)
                    до первого оператора break или до конца всего выражения switch
                - в частности если в блоке default нет break и он не последним,
                    будут выполнены все нижележащие блоки (до первого break)
                - если значению переменной есть соответствующий блок case
                    и в нем есть break - блок default не выполняется
                    если нет break - блок default будет выполнятся
                - иначе: блок default выполняется (независимо от позиции default):
                    * если в блоке case нет совпадений
                    * есть совпадение, но в этом блоке нет break

                switch (x) {
                    default:
                        ...; // выполняется, break нет
                    case 1:
                        ... // выполняется, независимо от значения х 
                }

        while

        do-while

        for 
            for (initialization; boolExpression; update) {
                // body
            }

            - все три блока - опциональны, но разделитель ";" обязателен
                напр. for( ; ; ) допустимо, for(;) нет
            - любой блок может содержать несколько операций, разделенных ','
                for(int i = 0, k =2; ; )
            - переменные объявленные в блоке инициализации, доступны только
                внутри цикла.
            - переменную можно объявить до цикла, но инициализировать в блоке
                инициализации (без указания типа), тогда видна после цикла
                int i = 5;
                for (i = 1; i<10; i++) 
            - порядок выполнения блоков: инициализация, проверка, если проходит
                - тело, обновление данных, проверка и т. д.
            - внутри блока инициализации можно объявлять несколько переменных,
                но только одного типа

        for-each
            для массивов и объектов, реализующих Iterable
            
            for(type instanse : collection) { ... }
            справа массив/iterable, слева - декларация переменной с типом
                равным типу членов коллекции

            ошибки:
                - справа не коллекция
                - тип слева не соответствует типу коллекции

        break
            метки

        continue
            метки

ch 3. Core API

    Strings
        создание:
            String s = new String("2222");
            String s = "1111"; // особый статус класса позволяет без new

        конкатенация
            правила для оператора "+":
                - если только числовые операнды - это арифметическое сложение
                - если хотя бы один операнд строка - конкатенация
                - вычисление слева направо
            напр.   4 + 2 + "а" -> "6a"
                    "a" + 4 + 2 -> "a42"

        Строки иммутабельны
            созданную строку изменить нельзя
            если функция обрабатывает строку, она всегда возвращает новую

        Пул строк
            все создаваемые строки (литералы, константы и их комбинации) 
                размещаются в пуле внутри JVM (экономия памяти)
            но использование new - игнорирует пул, в обычной памяти создает

        методы строк:

            int length()

            char charAt(int index)
                выход за границы - исключение

            int indexOf()
                поиск первого вхождения
                int indexOf(char ch)
                int indexOf(char ch, int fromIndex)
                int indexOf(String str)
                int indexOf(String str, int fromIndex)

                при неуспешном поиске возвращает -1

            substring()

                String substring(int beginIndex); // до конца строки
                String substring(int beginIndex, int endIndexExclusive);

                исключение при неверных индексах, end < begin
                при равенстве нач. и кон. индексов - пустая строка

            toLowerCase(), toUpperCase()

            equals(), equalsIgnoreCase()
                содержат ли две строки одинаковые символы в одинаковом порядке

            startsWith(), endsWith()
                boolean startsWith(String prefix);
                boolean endsWith(String suffix);

            contains()
                String replace(char oldChar, char newChar);
                String replace(CharSequence oldChar, CharSequence newChar);
                заменяет все вхождения
                CharSequence - интерфейс, подходят String, StringBuilder и др.

            trim()
                убирает пустые символы с конца, начала строки (пробелы, \t, \n, \r)

    StringBuilder
        
        Цепочки вызовов:
            если для строки каждый вызов в цепочке - возврат новой строки
            для StringBuilder - возврат ссылки на себя же (append())

        создание:
            new StringBuilder();
            new StringBuilder(String initial);
            new StringBuilder(int Capacity);

        методы
            charAt(), indexOf(), length(), substring()
                аналоги методов String
            append()
                StringBuilder append(String str);
                + под другие типы
            insert()
                вставляет строку с указанного индекса
                StringBuilder insert(int index, String str);
                + под другие типы
            delete(), deleteCharAt()
                StringBuilder delete(int start, int end); // конечный индекс не включается
                StringBuilder deleteCharAt(int index);
                выход первого индеска за границы - исключение
                первый больше второго - исключение
            reverse()
                StringBuilder reverse()
                без параметров, просто перестановка символов
            toString()

    StringBuffer
        аналог StringBuilder, но потокобезопасный и поэтому более медленный

    Равенство для ссылочных типов
        - логическое равенство (equals())
        - равенство объектов (==)

        ключевые моменты:
            - == проверяет равенство ссылок
            - строки-литералы в пуле будут равны
            - методы класса String возвращают новые строки, не будут равны исходной
            - в методе equals() логику сравнения можно переопределить
            - по умолчанию Object.equals() проверяет ссылки, поэтому если не 
                переопределен, equals() и == эквивалентны

    Массивы

        создание
            int[] arr = new int[3]; с указанием размера и со значениями по умолчанию
            int[] arr = new int[] {1, 4, 5}; с заданием значений
            int[] arr = {4, 5, 6}; анонимный массив, компилятор знает
            позиция [] не важна:
                int [] arr, int arr[] эквивалентны
            множественное определение:
                int[] a, b; два массива
                но int a[], b; - массив и переменная типа int
      
        массив - наследник Object, применимы toString(), equals() и т.п.
            toString() вывод внутреннее представление
            Arrays.toString(array) выводит перечисление элементов
      
        Приведение типов
            работает с массивами:
                String[] strings = {"a", "b"};
                Object[] objects = strings;
                String[] againStrings = (String[]) objects;
                strings[0] = new StringBuilder(); // не компилируется 
                objects[0] = new StringBuilder(); // компилируется, но в рантайме ошибка будет 
                    // (массив остался по факту массивом строк, элемент другого типа недопустим)
      
        Использование массивов
            array.length // не метод, свойство
            array[i]; // получение по индексу, выход за границы - исключение
      
        Сортировка
            import java.util.Arrays;
            Arrays.sort(array);
      
        Поиск
            Arrays.binarySearh(array, value);
            возвращает:
                если найден - индекс найденного
                если не найден - индекс предполагаемой позиции+1 со знаком минус (всегда < 0)
            работает только с сортированными массивами, для несортированного результат произвольный
            int[] array = {1, 4, 5};
            Arrays.binarySearh(array, 1); // -> 0
            Arrays.binarySearh(array, 4); // -> 1
            Arrays.binarySearh(array, 7); // -> -4

        varargs (variable arguments)
            способ указания параметров в объявлении метода
            public static void main(String... args) {}
            аналог массива, длина заранее неизвестна, только последним в списке параметров

        Многоразмерные массивы
            массивы содержат объекты, массив сам объект => массивы могут содержать массивы
            int[][] arr; // 2D
            int arr[][]; // 2D
            int[] arr[]; // 2D
            int[] arr[], arr2[][]; // 2D, 3D
            можно задавать размеры
            int[][] arr = new int[3][4];
            int[][] arr = {{1, 3}, {3}, {3, 4, 4}}; // не обязательно одинакового размера

            для многоразмерных массивов при создании обязательно указание первого размера
 
    ArrayList

        import java.util.ArrayList;
        ArrayList list = new ArrayList();
        ArrayList list = new ArrayList(10);
        ArrayList list = new ArrayList(list2);
        без указания типа - элементы типа Object
        
        ArrayList<String> list = new ArrayList<>();
        
        через интерфейс
        List<String> list = new ArrayList<>();

        методы
            add()
                boolean add(E elem); // всегда true возвращает
                void add(int index, E elem);
            remove()
                удаляет первое вхождение элемента
                boolean remove(E elem); // false если элемента нет
                E remove(int index); 
                исключение при превышении индекса
            set()
                E set(int index, E elem);
                устанавливает элемент по индексу
                исключение если индекс вне границ
            isEmpty()
                boolean isEmpty(); 
                пустой список или нет
            size()
                int size()
                размер возвращает
            clear()
                void clear()
                очищает список
            contains()
                boolean contains(E elem);
                через вызов equals()
            equals()
                содержит ли одинаковые объекты в том же порядке

    Классы-обертки
        каждый примитивный тип имеет обертку
            Integer i = new Integer(4);
        методы получения из строк:
            int i = Integer.parseInt("123"); // примитивный тип возвращает
            Integer i = Integer.valueOf("122"); // возвращает обертку
            исключение при неверных литералах

    Autoboxing
        автоматически преобразуются примитивные типы в обертки и обратно
        проблема с null:
            в List<Integer> можно положить, но извлечь в int нельзя (вызов метода у null)
        аккуратно с методами типа remove()
            List<Integer> list = ...;
            list.remove(1); // здесь 1 - индекс (сначала метод под примитивный тип подбирается)

    Преобразование массив <-> List
        List<String> list = ...;
        Object[] array = list.toArray(); // без указания типа - в Object[]
        но
        String[] array = list.toArray(new String[0]); // размер не важен, если не хватит - создастся новый

        из массива можно сделать "особый" list c неизменным размером
            List<String> list = Arrays.asList(array);
            изменение в list изменяют и массив и наоборот
            изменение размера list не допускается (исключение)

        asList работает с varargs
            List<String> list = Arrays.asList("a", "d");

    Сортировка списков:
        Collections.sort(list);

    Date, Time

        import java.time.*;

        LocalDate, LocalTime, LocalDateTime

        создание:
            - через статический метод now()
            - через статический метод of()
                static LocalDate of(int year, int month, int dayOfMonth);
                static LocalDate of(int year, Month month, int dayOfMonth);

                static LocalTime of(int hour, int minute);
                static LocalTime of(int hour, int minute, int second);
                static LocalTime of(int hour, int minute, int second, int nanos);

                для LocalDateTime различные комбинации +
                static LocalDateTime of(LocalDate date, LocalTime, time);

            явных конструкторов нет
                LocalDate date = new LocalDate(); // не компилируется
            для неверного месяца, числа - исключение

        использование:
            все объекты иммутабельны
            любые методы изменяющие объект, возвращают новый объект
            LocalDate не содержит никаких данных о времени, методы по работе 
                со временем не применимы 
            аналогично для LocalTime
            LocalDateTime имеет методы для времени и даты
            методы типа plusYear(), minusYear(), -Days, -Weeks, -Hours и т. п.
        
        Period
            класс для добавления к датам
            статические конструкторы
            Period.ofDays(), Period.ofWeeks(), Period.of(year, month, day)
            цепочки не работают: 
                Period.ofYears(1).ofDays(3); // только дни
            можно добавлять к дате LocalDate
                date.plus(period);
            но не к LocalTime, для времени свой класс Duration
            попытка добавить к дате Duration или к времени Period - исключение

        Форматирование

            класс java.time.format.DateTimeFormatter
            для дат и времени подходит
            через метод format()
                можно вызывать на объекте даты/время
                или на объекте DateTimeFormatter

            есть предопределенные
                time.format(DateTimeFormatter.ISO_LOCAL_TIME);
            или через метод ofLocalizedXXX
                DateTimeFormatter f = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
                f.format(date);
                причем для LocalDateTime можно любые форматтеры (только время, или только дату будут)
                для LocalDate и LocalTime -  только соответствующие форматтеры
                    иначе - исключение
                    

            произвольные шаблоны:
                M - месяц (MMMM - "январь", MMM -"янв", MM - "01", M - "1")
                dd - дата месяца
                ,
                yyyy - год (yyyy, yy)
                hh - часы (hh - с лидирующим нулем)
                :
                mm  - минуты
                
                DateTimeFormatter f = DateTimeFormatter.ofPattern("hh:mm");

                при форматировании - исключения, если будут часы для даты 
                    или дни для времени напр.

        Парсинг

            также с помощью DateTimeFormatter
            через статические методы классов LocalDate, LocalTime, ..
                parse()
            если не указан форматтер - используется по умолчанию
            если есть ошибки: несоответствие шаблону, неверные шаблон (дата для времени)
                исключение

            LocalDate date = LocalDate.parse("11:22");
            DateTimeFormatter f = DateTimeFormatter.ofPattern("MM yyyy");
            LocalDate date = LocalDate.parse("11 1990", f);

ch 4. Методы, инкапсуляция
    
    Создание методов
        
        Определение метода
            
            общий шаблон: 
            AccessModificator OptionalSpecifier ReturnType Name(params) throws Exception {
                // body
            }

            public final void foo(int i) {...}

            минимальное определение: возвращаемый тип + имя + параметры(пустые) + тело(пустое) 
                void foo() {}

        Модификаторы доступа:
            public - доступ к методу из любого места
            private - доступ только из того же класса
            protected - доступ из классов того же пакета или дочерних классов
            по умолчанию(package private) - доступ только из классов того же пакета

        Опциональные спецификаторы
            static, final, abstract, synchronized, native, strictfp
            может быть несколько, порядок их произвольный
            могут быть и перед модификатором доступа:
                final public void foo(){}

        Возвращаемый тип
            обязательно должен быть указан 
            void если ничего не возвращает
            оператор return должен возвращать тот же тип, что указан в объявлении
            если void, можно return; без указания
            внимание на условные выражения:
                String foo(int a) {
                    if (a == 4) return "bar"; // не скомпилируется, не всегда String возвращает
                }

        Имена методов:
            те же правила, что и для обычных переменных:
                буквы, цифры, $, _, не начинаться с цифры

        Параметры:
            любое количество (в т. ч. нулевое), перечислены через зпт
                внутри () после имени метода
            есть особые правила (напр. для varargs)

        Тело:
            любое количество выражений (нулевое) внутри блока {}

    Varargs
        некий аналог массива параметров
        только последним параметром в объявлении метода, т. е. только один на метод

        вызов метода:
            - передать array
            - перечислить списком через зпт, как обычные параметры
            - вообще опустить (будет создан пустой массив)
            - можно передать null, если внутри идет обращение - NullPointerExceprion

    Модификаторы доступа
        
        private
            только внутри класса

        default (package private)
            если не указан, доступ у всех внутри пакета


        protected
            то же самое что, default + доступ из дочерних классов

            пример:
                package p1;
                public class Foo {
                    protected void doWork() {}
                }

                package p2;
                public class Bar extends Foo {
                    public void check() {
                        doWork(); // все хорошо, через наследование и protected
                        Foo f = new Foo();
                        f.doWork(); // а здесь ошибка, через Foo нельзя получить доступ
                        Bar b = new Bar();
                        b.doWork(); // так же ошибка
                    }
                } 

        public 
            виден везде, всем

        Итоговая таблица
                                   / private / default / protected / public 
            -----------------------/---------/---------/-----------/-------
            внутри класса          /    +    /    +    /     +     /    +     
            др. класс, один пакет  /    -    /    +    /     +     /    + 
            дочерний, др. пакет    /    -    /    -    /     +     /    +        
            не дочерний, др. пакет /    -    /    -    /     -     /    +     

    Статические методы и поля

        Основы:

            для доступа к статическим членам класса не нужен экземпляр класса
            можно считать, что создается особый отдельный экземпляр и с ним работает
                каждый вызов статического метода и в нем хранится статическая переменная класса

            применение статических объектов:
                - для вспомогательных методов, для которых не нужно хранить состояние
                - для переменных, разделяемых всеми экземплярами класса (счетчик напр.)
                    для доступа к статическим переменным нужны статические методы

        Обращение к статическим полям/методам

            - через имя класса
            - через экземпляр класса также можно

            Пример:
                class Foo {
                    static String bar;
                }

                Foo.bar; // корректно
                Foo f = new Foo();
                f.bar; // корректно
                f = null;
                f.bar; // по-прежнему корректно, NPE нет, значение переменной не важно, важен тип

        static vs instance

            из статических методов нельзя обращаться к нестатическим полям / методам

            Тип              /    Вызывает  /  Допустимо? / Как?
            -----------------/ -------------/-------------/---------------
            static method    /    static    /  +          / через имя класса  
            static method    /    instance  /  -          / через переменную
            instance method  /    static    /  +          / через имя класса / переменную
            instance method  /    instance  /  +          / через переменную

            статические поля как и обычные поля инициализируются значениями по умолчанию

        Статические переменные

            - изменяемые (счетчики)
            - неизменяемые (константы) static final

        Статическая инициализация

            блок с ключевым словом static { ... }
            выполняется один раз при первом вызове класса
       
            ...
            private static final int a;
            private static final int b = 4;
            static {
                a = 3; // допустимо
                b = 3; // ошибка компиляции - второе присваивание final переменной    
            }

            final поля vs обычные:
                - обычные инициализируются значениями по умолчанию
                - final должны инициализироваться явно:
                    + при объявлении
                    + позже, один раз:
                        - static - не позже блока статической инициализации
                        - не-static - не позже констуктора

            в общем:
                блоки инициализации редко нужны:
                    не статический блок инициализации эквивалентен конструктору
                    статический применяется когда переменную нельзя инициализировать в 
                        одну строку (коллекция напр.)

        Статический импорт

            импорт статических полей / методов из класса

                import static java.util.Arrays.asList;

                ...
                List<String> l = asList("2", "3");
                если объявим свой метод asList, он будет использован

            порядок ключевых слов важен: import static, НЕ static import
            если импортировалии статический метод, обращаться к классу 
                нельзя без отдельного импортировалии
            импорт двух одинаковых полей/ методов - ошибка

    Передача данных в методы

        java использует передачу данных по значению (копия переменной передается)

    Перегрузка методов

        методы внутри одного класса с одинаковым именем и разными сигнатурами:
            - количество параметров
            - типы параметров
        остальное тоже может менятся:
            - возвращаемый тип
            - модификатор доступа
            - другие спецификаторы (static)
            - список исключений
        НО: изменение параметров обязательно!
            public void foo(int i) {}
            private boolean foo(long i) {} // допустимо
            public boolean foo(int i) {} // ошибка компиляции (параметры одинаковы)

        Overloading vs varargs:
            void foo(int[] a){}
            void foo(int... a){} // ошибка компиляции (varags ~ массиву)

        Autoboxing
            void foo(int i){}
            void foo(Integer i){} // допустимо
            foo(10); // вызывается первый вариант (зачем лишнее преобразование)

        Ссылочные типы
            общее правило: ищется наиболее специфичная версия метода

            void foo(String s){}
            void foo(Object o){}
            foo("2x"); // перыфй вариант
            foo(23); // второй вариант (boxing)

        Примитивные типы:
            аналогичное правило 
            + если для конкретного типа нет метода, возможно преобразование
                от меньшего к большему (int -> long и т.п.)

        Общие правила подбора метода (по убыванию):
            - точное совпадение типов и количества
            - бОльшие примитивные типы (!!! не boxing)
            - Autoboxing (но не напр. int -> long -> Long, слишком длинно)
            - varargs

    Конструкторы

        конструктор - специальный метод, с именем класса (сase sensitive)
             и без возвращаемого значения

        'new' - инстанциация с вызовом конструкора
        this - ссылка на себя

        Конструктор по умолчанию

            даже если явно не создавать, будет конструктор по умолчанию
                создан при компиляции
            типа 
                public Clazz() {}
            если задан хотя бы один конструктор, вызвать конструктор по умолчанию уже нельзя

            конструктор может быть приватным, тогда вне класса создать экземпляр нельзя

        Перегрузка конструкторов

            различаются параметры(количество/типы)

        Вызов одного конструктора из другого

            // первый конструктор
            public Clazz(int i, String s) {
                this.i = i;
                this.s = s;
            }
            // второй
            public Clazz(int i){
                Clazz(i, "default");  // НЕ компилируется (конструктор только с new)
                new Clazz(i, "default"); // компилируется, но результат игнорируется
                this(i, "default"); // то что нужно: через this вызывается конструктор
                // должен быть первым выражением в конструкторе
            }

        ключевое слово this:

            1. Ссылка на экземпляр класса внутри самого класса
            2. Вызов конструктора внутри другого конструктора (первая операция!!)

        final поля класса
            инициализируются:
                - при объявлении
                - в блоке инициализации
                - в конструкторе
            final поля инициализируются явно и не позже выхода из конструктора 
                (static до окончания блока статической инициализации)
    
    Порядок инициализации

        1. Инициализация суперкласса
        2. Объявление статитеских переменных и статические блоки инициализации
            в порядке объявления
        3. Объявление переменных экземпляра и обычные блоки инициализации
            в порядке объявления
        4. Конструктор             
        * если статический блок создает экземпляр, будут вызваны все обычные блоки
            инициализации и конструктор, а после остальные статические блоки


        public Clazz {
            static { ... } // 1) первый статический блок
            {...} // 3) первый перед конструктором
            static { new Clazz} // 2) второй статический блок, вызывается конструктор, поэтому запускаются обычные блоки
            Clazz () {... } // 4) сам конструктор
            static {...} //5) третий статический блок, но уже после иничиализации экземпляра
        }

    Инкапсуляция

        JavaBeans name conventions:
            - свойства объявляются приватными
            - геттеры для boolean начинаются с is-
            - геттеры для остальных - с get-
            - сеттеры начинаются с set-
            - после идет имя свойства с прописной

    Лямбда

        синтаксис:
            (a, b) -> {return ...;}
            () обязательны, если параметров больше одного, или 0, или один но с типом
                иначе () можно опустить, если один параметр и без указания типа
            {} обязательны, если больше одного выражения в блоке
            return обязателен, если есть {}
            ; обязательны, если есть {}

        Доступ к внешним переменным
            имеет доступ к полям класса (статические, обычные)
            к локальным переменным, параметрам если они эффективно final
            параметры, переданные в лямбда-выражение переопределять нельзя
                a -> {int a = 1; return 4;} // ошибка компиляции

ch.5 Дизайн классов

	Наследование
		
		Основы:
			наследование - процесс, при котором дочерний класс наследует 
				публичные и protected свойства / методы класса
			если класс Х наследник класса Y, Y наследник Z, тогда X также наследник Z
			java не поддерживает множественное наследование, только одиночное
			но допустима реализация нескольких интерфейсов
			но есть многоуровневое наследование
			если класс отмечен как final - наследовать его запрещено
		
		extends
			public abstract/final class X extends Y {...}		
			теперь Х имеет доступ ко всем публичным и protected членам класса Y

		модификаторы доступа для классов:
			- private - только для внутренних классов
			- protected - также только для внутренних
			- default - доступ к классу только внутри пакета
			- public - общедоступный класс

			файл может содержать только один public класс (или 0), но неограниченное
				количество default классов

			тоже самое для интерфейсов

		класс Object
			все классы java наследники Object
			можно считать, что если класс не наследует ничего, к нему 
				автоматически добавляется extends Object

		Конструкторы
			первая строка конструктора или this(), или super()
			как и в случае с конструктором обычным, если super() не вызывается явно, 
				будет неявно вызван конструктор родителя без параметров
			следующие объявления эквивалентны:
				public class D { }
				public class D {
					public D () {}					
                                }		
				public class D {
					public D () {
						super();
					}					
                }
			
			если в родительском классе объявлены конструкторы с параметрами,
				дочерний класс не может иметь конструктор по умолчанию или
				вызвать super() без параметров

				public class A {
					int a;
					public A(int a) { this.a = a;}
				}
				
				public class B extend A {
					// без конструктора нельзя
					public B() {} // конструктор без вызова super() нельзя
					public B() {  // только так
						super(4);
					}
				}
			
            Правила создания конструкторов:
                1. первое выражение любого конструктора:
                    или вызов другого конструктора этого класса через this()
                    или вызов конструктора родительского класса через super()
                2. ни this(), ни super() не могут вызыватся где-то, кроме первой строки
                3. если super() не вызван в конструкторе явно, компилятор вызовет первым
                    super() без аргументов
                4. если родитель не имеет конструктора без аргументов, а дочерний не имеет 
                    конструкторов вообще - ошибка компиляции
                5. если родитель не имеет конструктора без аргументов, в каждом конструкторе
                    дочернего должен вызываться конструктор через super

			Запуск конструкторов:
				первым вызывается конструктор родителя
				затем конструкторы текущего класса

        Вызов наследуемых свойств/методов
            дочерний класс может обращаться к членам родительского:
                public
                protected
                default (если дочерний и родительский - в одном пакете)
                к private полям напрямую нельзя
			
			this vs super
				this - обращение к элементам класса из текущего класса, 
                    наследуемым или текущего класса
				super - обращение только к наследуемым элементам из дочернего 
                    класса, к обычным - нельзя 	
			не путать super() (только в конструкторе) и super

		Наследование методов
			
			Переопределение методов
				Если методы с одинаковой сигнатурой есть в дочернем и родительском классах
					вызываться будет метод дочернего класса
				метод родительского можно вызвать через super
				
				Правила при переопределении методов:
					1. Сигнатуры методов в дочернем и родительском должны совпадать
					2. Метод в дочернем должен иметь такой же доступ или более 
                        расширенный (нельзя скрыть методы родителя)
					3. Метод в дочернем не должен вбрасывать новые исключения 
                        или исключения более общие, чем родительский
					4. Если метод родителя возвращает результат, дочерний метод 
                        должен возвращать тот же тип или подкласс возвращаемого родителем
					
					всё для того, чтобы вместо родительского метода можно было 
                        поставить дочерний

				не путать переопределение с перегрузкой:
					перегрузка - изменение сигнатуры, т. е. новый метод и поэтому 
                    больше допустимых изменений (напр. возвращаемый тип)
		
		Переопределение private методов
			
			технически переопределить частный метод в дочернем нельзя (просто недоступен)		
			можно создать метод с такой же сигнатурой, но с родительским он не будет 
                связан никак и никакие ограничения на него не действуют
	
		Сокрытие статических методов
		
			Если дочерний определяет статический метод с такой же сигнатурой, 
                что и статический метод родителя
			формально это не является переопределением
			но действуют те же 4 правила + дополнительно:
				5. Если метод родителя статический, дочерний также должен 
                    быть статическим (сокрытие). Если метод родителя не
                    статический, дочерний метод не может быть статическим (переопределение).
		
		Сокрытие vs переопределение:

			переопределенные дочерние методы заменяют родительские методы в 
                вызовах, определенных и в дочернем, и в родительском классах
			сокрытые дочерние методы заменяют родительские только в вызовах, 
                определенных в дочернем классе
		
			class A {
				void foo() {print("from A");} 
				static void bar() {print("stat A");}
				void doA() {foo();}
				void doAstatic() {bar();}
			}		
			
			class B extends A {
				void foo() {print("from B");}	// переопределение			
				static void bar() {print("stat B");} // сокрытие
				doB(foo();)
				void doBstatic() {bar();}
			}

			B b = new B();
			b.doA(); // from B // вызов определен в родителе, но неважно (переопределен)
			b.doB(); // from B // вызов в дочернем, но неважно (переопределен)
			b.doAstatic(); // stat A // вызов определен в родителе
			b.doBstatic(); // stat B // вызов в дочернем

            общие правила:
                - приватные поля/методы всегда скрываются
                - поля всегда скрываются (независимо от модификатора)
                - статические методы скрываются

        final методы

            final метод нельзя переопределять/скрывать в дочерних классах
                public final void ...
                public final static void ...

        Сокрытие переменных

            переопределять переменные в дочерних классах нельзя, только сокрытие:
                если определить переменную с таким же именем, что в родительском классе,
                    то будет два экземпляра переменной
                обращение из родительского класса - обращение к переменной родителя
                обращение из дочернего - обращение к переменной дочернего
                обращение из дочернего через super - обращение к переменной родителя

            одинаково для статических и не статических переменных
            на практике не рекомендуется переопределять переменные родителя

            Если B наследует A, тогда
                A a = new B();
                a.someVariable - это вызов переменной родителя

    Абстрактные классы

        основы:
            ключевое слово abstract 
                класс, отмеченный им не может инстанциироваться
                но может наследоваться
                абстрактный метод должен переопределятся

            public abstract class A {
                protected int len = 4;
                public abstract void do();
            }

        Объявление абстрактного класса:

            может содержать неабстрактные методы, поля
            абстрактный класс может вообще не иметь абстрактных методов
            но если есть абстрактный метод, класс обязан быть абстратным
            абстрактный метод не может иметь реализацию
            абстрактные методы, классы должны переопределятся, поэтому:
                - абстрактный класс не может быть final
                - абстрактный метод не может быть final
                - абстрактный метод не может быть private

        Создание конкретных классов

            абстрактный класс нельзя инстанциировать
            конкретный класс - первый дочерний класс, который реализует все абстрактне методы
            если класс наследует абстрактный класс, он должен реализовать все
                абстрактные методы (в т. ч. наследуемые родительским) или сам быть абстрактным

        Правила абстрактных классов:
            1. Абстрактный класс не может быть инстанциирован напрямую
            2. Абстрактный класс может иметь любое количество (в т. ч. 0) абстрактных и 
                не абстрактных методов
            3. Абстрактный класс не может быть private, final
            4. Абстрактный класс, наследующий другой абстрактный класс, наследует все 
                его абстрактные методы
            5. Первый конкретный класс, наследующий абстрактный, должен реализовать 
                все наследуемые абстрактные методы

        Правила абстрактных методов
            1. Абстрактный метод может быть определен только в абстрактном классе
            2. Абстрактный метод не может быть private или final 
            3. Абстрактный метод не может иметь тела/реализации в том классе, 
                где он определен абстрактным
            4. Реализация абстрактного метода в дочернем классе подчинена тем 
                же правилам, что и переопределение методов

    Интерфейсы

        Основы:
            интерфейс - абстрактный тип данных, определяющий набор абстрактных методов,
                которые должен реализовать класс, реализующий интерфейс

            public abstract interface MyInterface {   // abstract можно опустить, доступ: public / default
                public static final int someVar = 3;  // public static final можно опустить, вариантов больше нет
                public abstract void do();            // abstract можно опустить
            }

        Определение интерфейса
            можно считать особым видом абстрактного класса

            1. Интерфейс не может инстанциироваться напрямую
            2. Интерфейс не обязан иметь методы
            3. Интерфейс не может быть объявлен final
            4. Интерфейс верхнего уровня (не внутренний) должен быть public или с 
                default доступом и подразумевается abstract. Объявление такого интерфейса 
                private, protected или final - ошибка компиляции (несовместимо с abstract )
            5. Все методы интерфейса не по умолчанию предполагают public abstract модификаторы.
                Объявление методов private, protected или final  - ошибка компиляции


            public interface Foo {
                void bar();
            }
            public abstract interface Foo {
                public abstract void bar();
            }

            Эти два определения эквивалентны. abstract и public у метода подразумеваются
                и если явно не указаны, компилятор сам поставит (также как super() в конструкторе) 

        Наследование интерфейсов
        
            1. Интерфейс, наследующий другой интерфейс, наследует все его методы
                (как и абстрактные классы) как свои собственные 
            2. Первый конкретный класс, реализующий интерфейс или наследующий 
                абстрактный класс, реализующий интерфейс, должен реализовать 
                все методы интерфейса     
            
            public interface Int_A {}
            public interface Int_B {}
            public interface Int_C extends Int_A, Int_B {}

            допустимо множественное наследование
            если есть одинаковые методы в разных родителях - не проблема
                конкретный класс реализует один метод, который соответствует
                обоим интерфейсам
            абстрактный класс может реализовывать интерфейсы, при этом:
            	может реализовать методы 
            	может наследовать как абстрактные для последующей реализации

        Ключевые слова, классы, интерфейсы
            класс реализует интерфейс. наследует классы
            интерфейс наследует интерфейсы
            другие варианты недопустимы

            public interface A {]
            public class B extends A {} // не компилируется
            public interface D implements A {} // не компилируется
    	
        Методы и множественное наследование интерфейсов

            если в двух родителях объявлены медоды с одинаковой сигнатурой:
                ок, в реализации реализуем один раз
            если методы с одинаковым именем, но разной сигнатурой:
                обычная перегрузка методов, реализуем оба метода
            если в двух родителях объявлены медоды с одинаковой сигнатурой, но разными
                возвращаемыми типами:
                ошибка, как и с обычной перегрузкой
                причем ошибка будет даже без реализации, достаточно унаследовать
            	   два интерфейса с конфликтными методами
            					
        Переменные интерфейсов

            1. Подразумевается, что переменные объявляются как public static final.
                Попытка объявить private, protected, abstract - ошибка компиляции
            2. Т. к. это final-переменные, инициализироваться должны сразу при объявлении

            Как обычные статические переменные, доступ к ним есть без экземпляра,
                по имени интерфейса	
            указание public, static, final опционально, компилятор дополнит

        Методы интерфейса по умолчанию

            методы по умолчанию - метод, определенный внутри интерфейса с ключевым
                словом default и реализацией тела 

            класс, реализующий интерфейс, может переопределить метод по умолчанию
            цель введения была в обеспечении обратной совместимости: если есть классы,
                реализующие интерфейс, при добавлении нового метода в интерфейс можно обойтись
                реализацией по умолчанию без переделки всех классов

            public interface A {
                public default int doS() {
                    return 5;
                }
            }

            Правила методов по умолчанию:
                1. Метод по умолчанию может быть объявлен только внутри интерфейса
                    (не в классе, не в абстрактном классе)
                2. Метод по умолчанию должен быть объявлен с ключевым словом default
                    Если в объявлении есть default, должна быть реализация тела метода
                3. Метод по умолчанию не может быть static, final, abstract
                4. Метод по умолчанию должен быть public как и любой метод интерфейса

            Если интерфейс наследует интерфейс с методом по умолчанию, варианты:
                а) не изменяет метод, наследует сам метод и его реализацию
                б) переопределяет метод по стандартным правилам
                в) объявляет метод абстрактным, тогда реализация интерфейса будет
                    реализовывать
            эти же правила для абстрактных классов, реализующих интерфейс

        Методы по умолчанию и множественное наследование
            Если класс реализует два интерфейса, в которых определены методы
                по умолчанию с одинаковыми сигнатурами - ошибка компиляции
            Но класс может переопределить этот метод, тогда код скомпилируется

            public interface A {
                public default int doS() {return 5}
            }
            public interface B {
                public default int doS() {return 10}
            }
            public class C implements A, B {
                public int doS() {return 20} // так все ОК, без этого - ошибка компиляции
            }

            Эти же правила работают для абстрактных классов



        Статические методы интерфейсов

            1. объявляется с ключевым словом static
            2. как и все методы интерфейса подразумеваются public. Любые другие
                модификаторы - ошибка
            3. доступ к методу - через имя интерфейса
            4. классы, реализующие интерфейс со статическим методом НЕ наследуют
                статический метод и вызвать метод через имя/экземпляр метода нельзя

            проблем при множественном наследовании нет, т. к. класс не имеет доступа к 
                статическим методам

    Полиморфизм

        Основы
            Объект конкретного типа может быть присвоен переменной:
                - того же типа, что и объект
                - типа суперкласса, который наследуется классом объекта
                - типа интерфейса, который реализуется классом объекта или наследуется через суперкласс

            на этом основан полиморфизм
            Как только привсаивание произошло, доступны по ссылке переменной
                только методы и свойства типа этой переменной

            public interface A {
                public void doA();
            }
            public class B implements A {
                public void doA() {..}
                public void doB() {..}
            }

            A a = new B(); // ok
            B b = new B(); // ok
            a.doA(); // ok
            a.doB(); // error
            b.doA(); // ok
            b.doB(); // ok

        Object vs Reference

            Все объекты доступны только через ссылки. Напрямую к объекту, т. е. памяти,
                никак нельзя обратиться
            Независимо от того, переменной какого типа присваивается объект, сам
                объект никак не меняется

            Clazz cl = new Clazz();
            Object asObject = cl; // объект в памяти никак не изменился

            1. Тип объекта определяет какие методы/свойства есть у объекта в памяти
            2. Тип ссылки на объект определяет какие методы/свойства доступны к вызову через ссылку

            Присваивание одной переменной переменной другого типа дает доступ с другим методам

        Casting

            1. Преобразование от подкласса к суперклассу не требует явного приведения
            2. Преобразование от суперкласса к подклассу требует явного приведения
            3. Преобразование к несвязанным типам недопустимо
            4. Даже если компиляция выполняется без ошибок, в runtime возможны исключения
                при несовпадении типов

            напр.
                Class A {..}
                Class B extends A {..}
                A a = new A();
                B b = (B) a; // компиляция - без ошибок: переменная а типа А, который
                             // родитель для B и может в общем содержать объект типа B
                             // но в рантайме исключение: переменная a не содержит объект типа B

        Виртуальные методы

            виртуальный метод - метод, конкретная реализация которого не определена
                до момента выполнения

            фактически все не статические, не финальные и не приватные методы могут 
                считаться виртуальными, т. к. могут быть переопределены

            один из примеров:
                класс A, в нем определяем метод a1 , вызываем его в другом методе a2
                класс B, переопределяем метод a1
                теперь вызов метода a2 на объекте класса B будет всегда вызывать 
                    переопределенный вариант, независимо от типа ссылки

        Подиморфизм через параметры
            при объявлении метода типом параметра указывается интерфейс или суперкласс
            тогда при вызове уже указываем конкретный класс

ch.6 Исключения
    
    Иерархия исключений
       :           java.lang.Object
                          |
                    java.lang.Throwable
                      |                |
            java.lang.Exception    java.lang.Error
                      |
        java.lang.RuntimeException

        Error - ошибки
        RuntimeException - непроверяемые исключения
        checked exception - все субклассы Exception, кроме RuntimeException

        Перехватывать можно:
            RuntimeException
            checked exception

        Обязаны обрабатывать или объявлять:
            checked exception


      Еще:
        - термины: 
            declare exception = объявить через throws
            handle exception = в блоке catch
        - есть три типа исключений: ошибки, проверяемые, непроверяемые
        - что можем делать с исключениями:
            - объявлять в сигнатуре метода: любые
            - генерировать: любые
            - перехватывать: любые
            - как обычные классы
        - обязаны перехватывать/обрабатывать: только checked
        - в throws aka declare можно указывать любой класс Throwable, 
            т. е. любые ошибки, проверяемые, непроверяемые
        - перехватывать можно любые (RuntimeException + checked exception + Error)

         
    Оператор try

        try {
            // защищаемый код
        } catch (Exception_Type Identifier) {
            // обработчик исключения
        }   
        
        {} в обоих блоках обязательны
        если есть try, должен быть хотя бы один блок catch
            или должен быть блок finally, тогда можно без catch

    Блок finally
        try { ..
        } catch { ..
        } finally {
            // выполняется в любом случае, независимо было исключение или нет
        }
        если есть исключение, finally-блок выполняется после блока catch, иначе
            сразу после try

        при наличии finally, блок catch можно опустить:
            try {
            } finally { .. }

         У правила finally-блок выполняется всегда есть исключение: вызов System.exit
            в блоке try или catch: завершение программы происходит сразу

    Перехват разных типов исключений

        блоков catch может быть несколько
        при возникновении исключения проверяются все по порядку

        проблема может быть если исключения являются подклассами друг друга
        порядок, в котором более общее исключение, расположено ранее конкретного
            недопустим: тогда блок catch с конкретным исключением недостижим

        class MyException extends RuntimeException {}
        ..
        try{ ..
        } catch (RuntimeException e) {
        } catch (MyException e) {}   // ошибка компиляции

    Повторное вбрасывание исключения
        может быть вброшено в любом блоке: 
            try
            catch
            finally
        
        try {
              throw new RuntimeException();
            } catch (RuntimeException e) {
              throw new RuntimeException();
            } finally {
              throw new Exception();
            }
        }
        здесь try-блок генерирует исключение, catch-блок перехватывает и генерирует
            свое. Но в любом случае выполняется finally-блок, который затирает
            исключение от блока catch своим исключением

    Runtime exception
        наследуют RuntimeException
        не должны обрабатываться, но могут 
        генерируются программно или JVM

        ArithmeticException
            JVM генерирует при попытке деления на 0
        ArrayIndexOutOfBoundsException 
            JVM, при попытке обращения по неверному индексу
        ClassCastException
            JVM, преобразование объекта к типу, которым он не является
            причем:
                String s = "..";
                Integer n = (Integer) s; // это ошибка компиляции: компилятор знает
                                        // Integer не является подтипом String

                Object obj = s;
                Integer n = (Integer) obj; // здесь компиляция проходит: Integer подтип Object
                                           // но в рантайме - ClassCastException
        IllegalArgumentException
            программно вызывается, когда хотят напр. ограничить входные параметры методов
        NullPointerExceprion
            JVM, при попытке обращения через точку к null
        NumberFormatException
            программно, при преобразовании строк в число
            подкласс IllegalArgumentException

    Проверяемые исключения
        наследники Exception, но не RuntimeException
        должны обрабатываться, в сигнатурах явно указываются
        генерируются программно или JVM

        FileNotFoundException
            программно, при попытке обращения к несуществующему файлу
            подкласс IOException
        IOException
            программно, при ошибках чтения/записи файлов

    Ошибки (Error)
        наследники Error
        генерируются только JVM
        не должны обрабатываться

        ExceptionInInitializerError
            если статический блок инициализации класса выполняется с исключением e
                и без обработки, тогда сгенерируется ExceptionInInitializerError с причиной e

        StackOverflowException
            при вызове метода, параметры и локальные переменные хранятся в стеке
            при большом количестве вызовом - переполнение стека
            напр. бесконечная рекурсия 

            void rec(int i) { rec(1); }

        NoClassDefFoundError
            не найден класс в рантайме

    Вызов методов, генерирующих исключения

        при вызове метода с проверяемым исключением:
            или исключение перехватывается (try-catch)
            или в вызывающем методе декларируется исключение

        блок catch на проверяемое исключение, которое не может быть сгенерировано
            внутри блока try недопустим (недостижымый код)

    Исключения и переопределение методов (наследование / реализация интерфейса)
        при переопределении нельзя добавлять новое проверяемое исключение
        при переопределении можно указать более конкретное проверяемое
            исключение или не указывать вовсе
        но допустимо добавлять новые runtime exception:
            синтаксически это корректно, но не имеет смысла
            методы могут генерировать RuntimeException свободно, без указания в 
                сигнатуре метода, поэтому добавление в сигнатуру явно - избыточно 

    Печать исключений
        - печать через метод toString
        - печать сообщения исключения
        - печать stack trace

        catch (Exception e){
            System.out.println(e);
            System.out.println(e.getMessage());
            e.printStackTrace();
        }




