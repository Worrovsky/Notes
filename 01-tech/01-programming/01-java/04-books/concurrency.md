Concurrency in practice

Ch 1. Введение

    Опасности многопоточного приложения
        - надежность / безопасность / корректность
            ничего плохого не должно быть
        - жизнеспособность
            должно быть что-нибудь хорошее (нет блокировок)
        - производительность
            должно быть в приемлимое время



Ch 2. Потокобезопасность
    
    shared (разделяемый)    доступ есть из нескольких потоков
    mutable (изменяемый)    значение изменяется

    ПРАВИЛО:
    Если к одной переменной имеют доступ несколько потоков и хотя бы один
        может изменять эту переменную, все потоки должны координировать доступ
        к переменной через синхронизацию

    Проще сделать изначально сделать класс потокобезопасным чем потом переделывать

    Проблема понять к чему есть доступ из разных потоков: инкапсуляция 

    Определение потокобезопасности:
        класс потокобезопасен если он продолжает работать корректно (как в спецификации, ожидаемо)
            при доступе из нескольких потоков

    Пример потокобезопасности: stateless servlet
        сервлет без полей, результаты вычислений хранятся во внутренних переменных
        нет разделяемых частей, два потока никак не влияют друг на друга

    Объекты без разделяемых мутабелных переменных всегда потокобезопасны

    Причины нарушения потокобезобасности
        - Атомарность
            операции которые выполняются одноразово, без деления на части (напр. присваивание)
            инкремент ++i - не атомарная - read-modify-write

            напр. 
                public class UnSafeClass {
                    private int count = 0;
                    public void do(){ count++; }
                }

                при запуске в разных потоках 2 потока прочитают одно значение и изменят его одинаково

        - Состояние гонки (race condition)
            когда результат операции зависит от временного порядка, в котором выполняются части кода
            т. е. когда есть завязка на тайминг, на порядок операций (в потоках нет никакой гарантии на порядок и тайминги)

            сюда входит 
                read-modify-write
                check-tnen-act: 
                    сначала какая-то проверка
                    проверка проходит
                        ! в этот момент меняется состояние, действие выполняется над неверными данными
                        (файл не существовал, после проверки создали)
                    выполняется действие
            
                    пример: ленивая инициализация
                        class NotSafe {
                            private ExpensiveObj instance = null;

                            public ExpensiveObj getInstance(){
                                if (instance == null) {
                                    instance = getExpensiveObj();
                                }
                                return instance;
                            }
                        }
                        здесь два потока могут увидеть что instance = null, и оба запустить инициализацию

    обеспечение потокобезопасности:
        Составные действия 
            и check-tnen-act и read-modify-write нарушают потокобезопасность, потому что не являются атомарными
            необходимо выполнять набор операций как "составные", атомарные

            Операции А и Б будут атомарными по отношению друг к другу, если поток, выполняющий А, 
                либо видит полностью выполненную операцию Б другим потоком, 
                либо операция Б не начинала выполняться

            классы java.util.concurrent.atomic - атомарные переменные
                реализованые через механизм CompareAndSwap (CAS) процессоров
                public class AtomicInteger {
                    private int value;
                    public int get() {return value;};
                    public int incrementAndGet() {
                        while (true) {
                            int current = get();
                            int next = current++;
                            if (compareAndSwap(this, current, next)) 
                                return next;
                        }
                    }
                }
                здесь в compareAndSwap выполняются АТОМАРНО следующие действия:
                    читается значение value (this.get())
                    полученное значение сравнивается с current
                    если они равны, в value записывается next и возвращается true
                    иначе возвращается false

            если в stateless объект добавить одну атомарную переменную,
                объект останется потокобезопасным. Добавление нескольких - нарушает потокобезопасность

        locking
            даже если отдельные переменные - потокобезопасны (через использование atomic)
            в совокупности - нет гарантии
            напр.
                хотя index и value сами по себе атомарны, получение индекса и значения не составное действие
                    потоки могут вмешиваться в работу друг друга
                private AtomicInteger lastIndex;
                private AtomicInteger lastValue;

                ... 
                int i = lastIndex.get();
                if (i == ...) {
                    lastValue.get();
                }

            внутреннее блокирование intrinsic locking
                блок кода на основе объекта, содержащего код
                synchronized блок кода
                    - объект, который обеспечивает блокирование
                    - участок кода, защищаемый блоком

                synchronized (lock) {
                    // threadsafe  code
                }

                метод объявляется синхронизованным, любой объект сам может обеспечивать блокирование
                    class MyCl {
                        public synchronized void method() {...}
                    }
                внутреннее блокирование работает как мьютексы (mutual exclusion locks) (блокировки взаимного исключения)
                    если объект А устанавливает блок на методе, то никакой другой объект не сможет
                        выполнить метод, пока А не отпустит блокирование

        reentrancy (повторная входимость)
            свойство внутренних блокировок: успешное блокирование кода уже заблокированное 
                самим объектом
            поток, пытающийся заблокировать метод, уже заблокированный другим потоком, будет ждать
            поток, пытающийся заблокировать метод, уже заблокированный ИМ ЖЕ САМИМ, получит новый блок
                на каждый блок и владельца заводится счетчик, увеличивается при блокировании, уменьшается при 
                выполнении кода, дошел до 0 - освободил блок
            блокировка устанавливается на поток, не на вызов (per-thread / per-invocation)

            пример:
                public class Widget {
                    public synchronized void do() {...}
                }

                public class LockingWidget extends Widget{
                    public synchronized  void do() {
                        ...
                        super.do();
                    }
                }
                если бы не было reentrancy, LockingWidget ставит свой блок, вызова Widget::do не происходит -
                    заблокирован (хоть и тем же самым объектом LockingWidget) - deadlock

        защита блокированием
            составные действия или разделяемое состояния должны быть атомарными, чтобы избежать гонок условий
            объявление блока synchronized недостаточно
            для доступа к разделяемой переменой 2 условия:
                - синхронизация везде, где есть доступ к переменной (не только запись, но и чтение)
                - блок один и тот же, не разные

            встроенный блок класса не спасает от доступа к переменой из других классов
            выход - выделение мутабельных переменных в отдельные класс и блокирование через объект этого класса
                поддержка - чисто на программисте (добавил новый метод, забыл synchronized  - сломано)

            еще раз: синхронизировать нужно изменяемые данные, доступные из нескольких потоков

            ситуация: была однопоточная программа, синхронизации не были нужны, добавили Timer
                теперь нужно синхронизировать изменяемые переменные

            делать все методы synchronized не выход, нужно  синхронизировать комбинации операций
                if (!vector.contains(el)){
                    vector.add(el);
                }

        блокировки и производительность

            пока метод блокирован - другие потоки ждут, на высокой нагрузке - простои
            нужно уменьшать область видимости синхронизированных методов, исключать операции, не влияющие на разделяемое состояние
                выделением методов
                выделением блока в методе
                    public void do () {
                        ...
                        synchronized (this) {
                            ...
                        }
                        ...
                    }
            частое введение synchronized уменьшает производительность

Ch 3. Разделяемые объекты
    
    synchronized-блок решает следующие проблемы многопоточности:
        - обеспечивает атомарность операций
        - выделяет критические секции
        + "видимость памяти": если один поток меняет данные, когда другие потоки увидят это изменение
   
    3.1 Видимость

        Основы
            однопоточная: записываем переменную, потом читаем - получаем значение записанное
            в многопоточных нет гарантии если запись и чтение в разных потоках

            пример
                private static int number;
                private static boolean ready;

                private static class ReaderThread extends Thread {
                    public void run() {
                        while (!ready) 
                            Thread.yield();
                        System.out.println(number);
                    }
                }
                public static void main(String[] args) {
                    new ReaderThread().start();
                    number = 42;
                    ready = true;
                }
                поток ReaderThread может прочитать значение number как 42, 0 или вообще не остановится

            компиляторы могут менять порядок операций и без синхронизации читающий поток увидит сначала
                запись ready, а только потом number

            Синхронизация нужна везде, где есть разделяемые данные

        3.1.1 Несвежие данные
            пока синхронизация не используется каждый раз, когда есть доступ к переменной,
                можно получить "несвежее" значение этой переменой

            пример
                class MutableInt {
                    private int value;
                    public void set(int v) {value = v;}
                    public int get() {return value;}
                }
                пока в одном потоке устанавливается значение, другой поток может прочитать неверное значение

        3.1.2 Неатомарные 64-битные операции
            кроме несвежих данных, могут получаться случайные значения
            out-of-thin-air safety - защита от данных из ниоткуда
            все переменные, кроме double, long, обеспечивают out-of-thin-air safety
            64-битные значения double, long обрабатываются за 2 32-битные неатомарные операции
            выход:
                - обработка в блоке
                - объявление volatile

        3.1.3 Блокирование и видимость
            блок не только обеспечивает взаимное исключение, но и организует видимость памяти
            последовательность:
                поток А устанавливает блок
                поток А выполняет операции
                поток А освобождает блок
                поток Б устанавливает блок _на том же объекте_
                поток Б будет видеть результат всех операции потока А
            если нет блока / блок на другом объекте - видимость не гарантируется

        3.1.4 volatile переменные
            слабая альтернатива синхронизации
            чтобы изменения переменной происходили предсказуемо для других потоков
            указания для компилятора и runtime:
                - операции с переменной не должны менять порядок
                - запрет на кеширование, чтобы чтение этой переменной всегда давало последние изменения
            можно считать как аналог класса с синхронизированными методами get, set, но чуть менее затратным
                (блокировок нет)
            если в потоке А volatile-переменной установлено значение, то поток Б после читающий переменную
                может безопасно читать все другие переменные, установленные в А до volatile-переменной
                но лучше так не делать, а явно блоком synchronized 

            блокирование обеспечивает и атомарность, и видимость, volatile-переменные только видимость

            volatile-переменные не обеспечивают безопасность при инкрементах
            условия применения:
                - запись в переменную никак не зависит от текущего состояния (флаг, но не счетчик)
                - переменная не образует состояние вместе с другими переменными, сама по себе (не в инварианте)
                - нет других причин для блокирования доступа

            применяются для флагов статуса, завершения, прерывания

    3.2 Публикация и побег 

        Основы
            Публикация - доступ к объекту вне его текущей видимости:
                - через сохранение ссылки, где другой код может найти
                - через возвращение из метода
                - через передачу параметром
              
            обычно хотят скрыть объекты (инкапсуляция)
            если хотят показывать, в многопоточной среде нужны доп. меры           
            объект, который был опубликован когда этого не должно было произойти
                - сбежавший (escaped) (напр. стал виден до полной инициализации)

            примеры публикаций:
                - публичная статическая переменная (доступ к ней у всех)
                - косвенная публикация: публикуется коллекция, есть доступ к ее элементам
                - публикуется объект, все публичные поля также доступны
                - передача объекта чужому методу (другие классы, переопределяемые методы)
                     (не знаем что с ним делают)
                - публикация через внутренний класс (передача в обработчик-листенер, есть ссылка на this)

        3.2.1 Методы безопасного построения
            частая ошибка - старт потока в конструкторе (передается ссылка this потоку)
                объект не создан полностью, пока не было выхода из конструктора
                даже если старт потока - последняя строка
                поток можно создавать в конструкторе, но запуск лучше отложить
                решается через приватный конструктор и фабричный метод,
                    в котором запускается поток или регистрируется listener

    3.3 Ограничение потока
        если мутабельный объект используется из разных потоков - угроза безопасности
            нужна синхронизация
        один из выходов - ограничить одним потоком использование (не давать общий доступ)
            (сам объект может быть не потокобезопасным)

        примеры:
            Swing: компоненты Swing можно использовать только в потоке обработки событий
            JDBC: пул соединений (объектов Connection), выдается соединение одному потоку,
                пока не отработано, другим не дается

        ограничение потоков - через дизайн программы (не средства языка)

        Способы ограничения потока
            - специальное ограничение: полностью через реализацию / программно
                сложно, т.к. нет никакой помощи со стороны языка
                не рекомендуется
                частный случай: volatile-переменная с записью только в одном потоке
            - ограничение стека (внутрипоточное)
                доступ к объекту только через локальные переменные
                локальные переменные хранятся в стеке только одного потока 
                для примитивных типов это работает "из коробки", для ссылочных
                    отслеживать, чтобы не передать ссылку наружу (не убежал объект)
            - класс ThreadLocal
                позволяет связать каждый поток со своим значением
                метод get() будет всегда возвращать то значение, которое
                    было установлено методом set() в том же самом потоке
                аналог локальной переменной
                пример:
                    свое соединение на каждый поток при подключении к БД

                    private static ThreadLocal<Connection> conHolder = new ThreadLocal<Connection>() {
                        public Connection initialValue() {
                            return DriverMAnager.getConnection(URL);
                        }
                    };

                    public static Connection getConnection() {
                        return conHolder.get();
                    }

                применяется когда на каждый поток необходимо свое значение (напр. буфер)
                значения, ассоциированные с потоком, хранятся в самом потоке,  
                    при завершении потока будут убраны GC
                может служить как глобальная переменная / скрытые аргументы (если объявить static)

    3.4 Неизменяемость

        неизменяемый (immutable) объект - объект, состояние которого не меняется после 
            создания/построения (конструктором)
        если объект неизменяем - он потокобезопасен

        условия иммутабельности:
            - состояние не меняется после построения
            - все поля объявлены как final (одного этого недостаточно, поля могут содержать ссылки)
            - правильно построен (this не может сбежать во время построения)

        3.4.1 final поля:
            указание компилятору, что поле не может быть изменено
            хотя если это ссылка, сам объект может изменяется
            + дополнительное ограничение на модель памяти
            объявление полей final дает гарантию безопасной инициализации (3.5.2)
            объявление поля final, если оно не должно менятся, хорошая практика

        3.4.2 публикация ссылки на неизменяемый объект через volatile-переменную
            согласованное изменение 2-х и более переменных необходимо выполнять атомарно
                (напр. через блокировки)
            можно использовать комбинацию:
                неизменяемый объект и volatile-переменная для ссылки на этот объект

    3.5 Безопасная публикация

        Публикация - когда ссылка на объект становится видна другим
        что может пойти не так:
            - будет прочитано неверное значение ссылки (null, старое)
            - поля объекта могут оказаться в несогласованном состоянии

        3.5.2 Публикация немутабельных объектов
            неизменяемые объекты безопасно могут использоваться любым потоком, 
                даже если при публикации ссылки на них не использовалась синхронизация

            Синхронизация нужна, если поля объекта - ссылочные

        3.5.3 Публикация изменяемых объектов (касательно ссылки)

            в общем случае нужна синхронизация публикующего потока и потребляющего

            правильно построенный объект может публиковаться:
                - инициализацией ссылки из статического инициализатора
                    public static Holder holder = new Holder(42);
                    спецификация JLS [12.4.2] гарантирует, что этот код будет выполнен во время
                        инициализации класса
                - хранением ссылки на объект в поле типа volatile или AtomicReference
                - сохранением ссылки в поле final корректно построенного объекта (?)
                - сохранением ссылки в поле, защищенным блокировкой
                    потокобезопасные коллекции так работают, поэтому размещение
                    ключей/значений в них дает безопасную публикацию

        3.5.4 Фактически неизменяемые объекты
            технически изменяемые, но состояние не будет менятся после публикации

            безопасно опубликованные фактически неизменяемые объекты могут 
                безопасно использоваться без дополнительной синхронизации

            напр. объект Date изменяемый. Но если не собираемся менять после 
                создания, можно поместить в потокобезопасную synchronizedMap
                и этого будет достаточно

        3.5.5 Изменяемые объекты
            должны быть безопасно опубликованы и синхронизированы при каждом обращении

            общие правила:
                - неизменяемые объекты могут публиковаться любыми способами
                - фактически неизменяемые должны быть безопасно опубликованы
                - изменяемые должны быть безопасно опубликованы и быть 
                    потокобезопасными или защищаться блокировками

        3.5.6 Общие практики совместного использования объектов:
            - не иcпользовать совместный доступ (ограничение потоков)
            - совместный доступ только на чтение (может быть доступен 
                нескольким потокам без синхронизации, не может быть изменен
                ни одним потоком (неизменяемые или фактически неизменяемые объекты))
            - совместное использование потокобезопасных объектов
                (синхронизация внутри реализована)
            - защищенные объекты

Ch 4. Компоновка объектов (шаблоны построения потокобезопасных классов)

    4.1 Проектирование потокобезопасных классов

        Инкапсуляция -  основной способ создания потокобезопасных классов 

        Процесс проектирования:
            - определение переменных, формирующих состояние класса
                если поля примитивные, состояние определяется целиком этими переменными
                для n переменных, состояния - n-мерный массив
                если переменные ссылочного - состояние включает переменные объектов по ссылкам
            - определение инвариантов, ограничивающих переменные состояния
            - установление политики для совместного доступа к состоянию
                определяет как синхронизируется общий доступ (ограничения
                потоков, иммутабельность, блокировки и т.п.)

        4.1.1 Сбор требований к синхронизации

            Сделать класс потокобезопасным - гарантировать, что инварианты будут
                сохранены при параллельном доступе
            Пространство состояний (все возможные варианты) чем меньше, 
                тем проще его анализировать. Сделав поля final или немутабельным - 
                уменьшаем пространство состояний
            Классы имеют инварианты, которые делят состояния на допустимые и недопустимые
                напр. Counter c полем типа long: long ограничен min и max,
                    + счетчик только положительный
            Переходы между состояниями также могут быть допустимыми и недопустимыми
                напр. счетчик из состояния 17 должен перейти в 18. Когда состояние 
                выводится из предыдущего - это составное действие
            Если есть недопустимые состояния, переменные должны быть инкапсулированы,
                чтобы клиентский код не перевел их в недопустимое
            Если есть недопустимые переходы, операция должна быть атомарной
            Если есть инварианты, ограничивающие сразу несколько переменных
                (напр. диапазон с границами, нижняя всегда не больше верхней)
                тогда нужна атомарность на обновление/чтение связанных переменных
            В остальных случаях минимизируем доп. затраты на инкапсуляцию, синхронизацию

            Инварианты и постусловия - ключ к построению потокобезопасных классов
            Инкапсуляция и атомарность - способы

        4.1.2 Операции, зависящие от состояния

            Инварианты и постусловия ограничивают допустимые состояния и переходы между ними
            Объекты могут иметь методы с условиями на основе состояния 
                напр. нельзя удалить элемент из пустого списка

            В многопоточной программе предварительные условия могут выполняться позже
                можно ждать пока выполнится условие и затем продолжать операцию

            Варианты ожидания:
                - на wait/notify (сложно)
                - блокирующие очереди, семафоры

    4.2 Органичение экземпляра

        Основы
            Не потокобезопасные объекты можно безопасно использовать в многопоточной
                среде: ограничение потока или синхронизация

            Ограничение экземпляра - когда объект(ы) инкапсулируется в другом объекте.
                Это облегчает анализ и построение блокировок
            Инкапсуляция + блокировки -> потокобезопасный класс
            Важно не допускать избегания объекта из области видимости

            Пример:
                public class PersonSet {
                    private final Set<Person> mySet = new HashSet<>();

                    public synchronized void addPerson(Person p) {
                        mySet.add(p);
                    }
                    public synchronized boolean containsPerson(Person p) {
                        return mySet.contains(p);
                    }
                }
                Здесь не потокобезопасный HashSet оборачивается в PersonSet и
                    за счет блокировок достигается потокобезопасность.
                    Класс Person может вызвать нарушение потокобезопасности

            Стандартная библиотека предоставляет потокобезопасные коллекции,
                построенные по такому же принципу. Методы типа Collections.SynchronizedList
                возвращают обертку над стандартным списком. Методы синхронизированы 
                и просто перенаправляют запрос к стандартным (шаблон "Декоратор")
                Пока базовая коллекция не имеет доступа вне обертки - 
                безопасность гарантирована

            Побег объектов при методе ограничения экземпляра - нарушение потокобезопасности

        4.2.1 Шаблон "Монитор"

            Логическое завершение принципа ограничения экземпляра
            Объект по шаблону монитор инкапсулирует свое изменяемое состояние 
                и защищает его своей внутренней блокировкой

            Пример монитора - простой Counter с синхронизацией на самом же объекте
                Counter.
            Можно синхронизацию строить на отдельном приватном объекте:
                public class Counter {
                    private Object myLock = new Object();
                    public void get() {
                        synchronized(myLock) {...}
                    }
                }
            Преимущество синхронизации на отдельном приватном объекте:
                клиентский код не получает доступ к объекту блокировки 
                и не может сам устанавливать блокировки
                не нужно анализировать код вне класса

    4.3 Делегирование потокобезопасности

        Вопрос: если компонент класса потокобезопасный, нужно дополнительно 
            обеспечивать потокобезопасность? ответ: зависит от ...

        4.3.1 Делегирование одной переменной состояния

            Напр. Counter можно построить на AtomicLong без доп. мер
            Класс Counter "делегирует" обеспечение потокобезопасности переменной
                AtomicLong

        4.3.2 Независимые переменные состояния

            Делегирование будет работать, если несколько переменных не 
                образуют инварианты совместно
            Напр. компонент, регистрирующий обработчики нажатий мыши и клавиатуры
                эти события независимы, и если списки потокобезопасны, компонент 
                также будет потокобезопасным

        4.3.3 Когда делегирование не работает

            - переменные образуют инварианты в совокупности
            - над переменными выполняются составные действия

            Пример: класс NumberRange с переменными lower, upper типа AtomicLong
                должно выполняться условие upper >= lower
                public void setLower(long i) {
                    if (i < upper.get) {
                        throw new Exception(...);
                    }
                    lower.set(i);
                }
                + check-tnen-act должен атомарно выполняться

        4.3.4 Публикация базовых переменных состояния

            Условия безопасной публикации:
                - переменная потокобезопасна
                - не участвует в инвариантах, ограничивающих ее значение
                - нет запрещенных переходов

            Напр. нельзя публиковать внутреннюю переменную счетчика 
                (переходы от больших к меньшим запрещены)

    4.4 Добавление функциональности в существующие потокобезопасные классы

        напр. нужен класс  List с операцией поместить-если-отсутсвует
        это составное действие, нужно обемпечивать атомарность
        Способы:
            - изменение исходного класса
                понять политику синхронизации, обеспечить то же для нового кода
                удобно поддерживать при изменении исходного класса
            - расширение исходного класса (наследование и т. п.)
                минус: политика безопасности разнесена по нескольким файлам
            - использование вспомогательного класса

        4.4.1 Блокировки на стороне клиента

            вариант использования вспомогательного класса

            @NotThreadSafe
            public class ListHelper<E> {
                public List<E> list = Collections.SynchronizedList(new ArrayList<E>());
                ...
                public synchronized boolean putIfAbsent(E x){...}
            }
            обертка не потокобезопасна, т. к. блокировка осуществляется 
                на разных объектах (метод putIfAbsent на объекте ListHelper,
                внутри списка - на объекте List)


            нужно использовать ту же блокировку, что и объект List 
                (внешняя блокировка / блокировка на стороне клиента)
                для этого нужно знать, какую блокировку использует объект

            public boolean putIfAbsent() {
                synchronized(list) {...}
            }

            Минусы:
                - хрупкое решение (код блокировки класса С попадает в 
                    классы, никак не связанные с С)
                - нарушается инкапсуляция политики синхронизации

        4.4.2 Композиция

            @ThreadSafe
            public class ImprovedList<T> implements List<T> {
                private final List<T> list;

                public ImprovedList(List<T> list) { this.list = list; }

                public synchronized boolean putIfAbsent(T x) {...}

                public synchronized void clear() { list.clear(); }

                // другие методы аналогично через обращение к list
                // list вовне передаваться не должна 

            }

            Плюсы / минусы:
                - добавляется дополнительный уровень блокировок, что немного
                    снижает производительность
                - исходный класс не должен быть потообезопасным
                - менее хрупкая реализация, знания о внутреннем устройстве 
                    исходного класса не нужны
                - это шаблон Монитор с одной переменной

    4.5 Документирование политики безопасности

        Документируйте гарантии потокобезопасности для клиентов класса
        Документируйте политику синхронизации для сопровождающих

        Вопросы, на котороые нужно ответить:
            - каждое использоание volatile, synchronized, потокобезопасного 
                класса должно быть отражено в политике
            - какие блокировки что защищают
            - какие переченные должны быть неизменяемыми

        для клиентов:
            - какие операции потокобезопасны
            - поддерживается ли блокировка на стороне клиента
     

Ch 5. Строительные блоки
    
    5.1 Синхронизированные коллекции 

        5.1.0 
            Vector, Hashtable, Collections.synchronizedXxx
            потокобезопасность через инкапсуляцию и синхронизацию открытых методов

        5.1.1 Проблемы

            нужна дополнительная синхронизация на стороне клиента при 
                составных операциях (итерация, навигация, условные операции)
            технически они будут работать и без дополнительной синхронизации,
                но результат может быть не тем, что ожидали

            пример получения последнего элемента
                public static Object getLast(Vector list){
                    int lastIndex = list.size() - 1;
                    return list.get(lastIndex);
                }
                здесь между получением индекса и получением элемента
                    другой поток может удалить элемент, получим исключение

            Зная политику синхронизации (для класса Vector - на самом объекте)
                можно так:
                public static Object getLast(Vector list){
                    synchronized (list) {
                        int lastIndex = list.size() - 1;
                        return list.get(lastIndex);
                    }
                }

            аналогично при итерации
                for (int i=0; i<vector.size(); i++) {
                    doSomething(vector.get(i));
                }
            нужна синхронизация, но блок на период итерации - ухудшение производительности

        5.1.2 Итераторы и ConcurrentModificationExeption

            Итераторы (явно или неявно через for-each) также не предназначены
                для работы в многопоточной среде
            могут обнаруживать изменение коллекции с момента итерации 
                реализовано через счетчик изменений, если он меняется во время итерации
                методы hasNext() и next() вызывают исключение ConcurrentModificationExeption
                счетчик без блокировок работает (производительность), поэтому не всегда обнаруживает
                просто как способ обнаружения проблем
            т.е. в общем случае нужна синхронизация на этапе итерирования
                но проблемы:
                    - ухудшение производительности (коллекция занята)
                    - методы обработки также могут выполнять блокирование
                        -> взаимоблокировки
            альтернативное решение:
                копирование коллекции, итерация на копии
                на время копирования коллекция должна быть блокирована
                что лучше - на основе частоты итераций, размере коллекций,
                    работе над каждым элементом

        5.1.3 Скрытые итераторы

            многие методы неявно вызывают итерацию:
                - toString(), hashCode(), equals() вызываемые на коллекциях
                - containsAll(), removeAll()
                - конструкторы с параметрами типа коллекций

            Чем больше расстояние между состоянием и синхронизацией, его 
                защищающей - тем больше вероятность, что кто-то упустит

    5.2 Параллельные коллекции

        5.2.0

            два вида коллекций:
                - синхронизированные - каждый метод синхронизируется
                    * проблемы производительности 
                - параллельные 
                    * блокировки не сплошные
                    * для улучшения производительности
                    * ConcurrentHashMap, CopyOnWriteArrayList
                    * ConcurrentSkipListMap, ConcurrentSkipListSet

        5.2.1 Класс ConcurrentHashMap

            обычная синхронизированная HashMap блокирует каждую операцию полностью
            некоторые операции могут занимать продолжительное время
            ConcurrentHashMap основана на чередуемой блокировке:
                читатели могут параллельно иметь доступ к коллекции
                читатели могут получать доступ одновременно с писателями
                ограниченное количество писателей может одновременно работать
                бОльшая производительность в многопоточной, меньшая в однопоточной
            итераторы ConcurrentHashMap:
                - не выдают ConcurrentModificationExeption
                - нет нужды в блокировке
                - слабо согласованы: обход той коллекции, что была на момент
                    построения итератора, или может отражать изменения
            ослаблены методы size(), isEmpty(): не гарантируется актуальное значение
                (оно и не сильно необходимо в задачах)
            операции get(), put(), remove(), containsKey() гарантируются
            не позволит установить монопольный доступ к коллекции

            в общем замена синхронизированных коллекций на ConcurrentHashMap 
                ведет к улучшению производительности

        5.2.2 Дополнительные атомарные операции ConcurrentHashMap

            т.к. нельзя установить монопольный доступ, для ConcurrentHashMap
                нельзя добавить пользовательские синхронизированные методы
                (через блокировку на стороне клиента)

            поэтому добавлены в интерфейс 

            public interface ConcurrentMap<K, V> extends Map {
                // помещает, если отсутствует
                V putIfAbsent(K key, V value);
                // удаляет, только если есть в коллекции
                boolean remove(K key, V value);
                // замещает, если K есть 
                V replace(K key, V value);
            }

        5.2.3 Класс CopyOnWriteArrayList

            параллельная замена для синхронизованной реализации List
            скопировать-при-записи (copy-on-write):
                копируют и публикуют коллекцию при каждом изменении
                сама коллекция в таком случае фактически неизменна
                итераторы хранят копию коллекции на момент начала итерации
                синхронизация нужна только для публикаци ссылки

            целесообразно использовать когда итерация используется чаще 
                чем модификация 

    5.3 Блокирующие очереди и шаблон Производитель-Потребитель

        5.3.0
            методы очередей:
                put() - помещает элемент в очередь, блокируется если очередь 
                    полностью заполнена до освобождения
                take() - извлекает элемент, блокируется если очередь пуста
                    до появления элементов
                offer(), poll() - аналоги с ограничением по времени

            Производитель-Потребитель:
                обна общая очередь: производитель(ли) помещают объекты
                    потребитель (ли) извлекают
                отделяет идентификацию работы от выполнения этой работы
                отделяет класс производителей от класса потребителей
                позволяет управлять нагрузкой

            Пример: пул потоков с рабочей очередью, фреймворк Executor

            Реализации BlockingQueue: 
                FIFO: LinkedBlockingQueue, ArrayBlockingQueue
                PriorityBlockingQueue

        5.3.2 Последовательное ограничение потока

            блокирующие очереди могут безопасно публиковать объекты
                от потока-производителя потоку-потребителю
            можно организовать последовательное ограничение потоков
                публикация есть
                просто обеспечиваем, что производитель не будет менять объект
                    после передачи потребителю и не опубликует его вовне


        5.3.3 Двусторонние очереди, кража работы

            интерфейсы Deque ("дек"), BlockingDeque и их реализации 
                ArrayDeque, LinkedBlockingDeque

            позволяют вставлять / удалять элементы с головы и с хвоста

            кража работы: 
                у каждого потребителя своя двустороняя очередь
                когда своя пуста - берет с хвоста чужой
                конкуренция между работниками уменьшена (над своей очередью
                    больше, даже если в чужую - с хвоста)
                потребители более загружены

            подходит когда потребители также являются производителями
            напр. обход веб-страниц: во время обхода - новые страницы,
                помещает в конец своей очереди
                другие потребители будут помогать
            алгоритмы над графами

    5.4 Методы блокирования и прерывания

        interrupt(), перехват исключений
        
    5.5 Синхронизаторы

        5.5.0
            Синхронизатор - любой объект, который контролирует потоки 
                на основе своего состояния

            Блокирующие очереди - пример синхронизатора. Потоки производителя
                и потребителя блокируются методами put(), take()

            Другие примеры:
                семафоры
                защелки
                барьеры
                соственные классы     

        5.5.1 Защелки

            Защелка - синхронизатор, который задерживает выполнение потоков,
                пока защелка не достигнет конечного (терминального) состояния 
            По достижении конечного состояния состояние больше не меняет, 
                остается всегда открытой

            примеры использования:
                вычисление не должно выполняться, пока не инициализированы ресурсы
                служба не запускается, пока не запущены другие службы
                ожидание, пока все стороны в некоторой деятельности, не будут готовы

            класс CountDownLatch
                счетчик, инициализируется положительным числом
                метод countDown() уменьшает значение счетчика
                метод await() блокируется, пока счетчик не достигнет нуля

            public class TestTime{
                public long timeTask(int nThreads, final Runnable task) {
                    final CountDownLatch startGate = new CountDownLatch(1);
                    final CountDownLatch endGate = new CountDownLatch(nThreads);

                    for (int i=0; i<nThreads; i++) {
                        Thread t = new Thread() {
                            public void run() {
                                try {
                                    startGate.await();
                                    try {
                                        task.run()
                                    } finally {
                                        endGate.countDown();
                                    }
                                }
                            }
                        };
                        t.start();
                    }
                    long start = System.nanoTime();
                    // до этого момента все потоки блокированы на переменной startGate
                    // теперь снимаем блокировку
                    startGate.countDown();
                    // ждем пока все потоки не выполнятся и не снимут блокировку с endGate
                    endGate.await();
                    return System.nanoTime() - start;

                }
            }

        5.5.2 Класс FutureTask

            интерфейс Future, описывающий абстрактный результат
            вычисление реализуется через Callable
            может находиться в трех состояниях:
                ожидание(выполнения), выполнение, завершено (корректно, отменено или через исключение)

            поведение Future.get() зависит от состояния:
                завершено - немедлено возвращает результат
                иначе - блокируется до завершения (прерывания/остановки)
            гарантируется корретная публикация результата

            пример использования: запуск длительных вычислений, которые запускаются
                до того, как понадобятся их результаты

            public class Preloader {
                private final FutureTask<ProductInfo> future = 
                    new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
                        public ProductInfo call() throws DataLoadExeption{
                            return loadInfo();
                        }
                    });   
                private final Thread t = new Thread(future); 

                public void start() {t.start();}

                public ProductInfo get() throws DataLoadException, InterruptedException {
                    try {
                        return future.get();
                    } catch (ExecutionException e) {
                        Throwable cause = e.getCause();
                        if (cause instanceof DataLoadException) {
                            throw (DataLoadException) cause;
                        } else {
                            throw launderThrowable(cause);
                        }  
                    }
                }
            }

            Общий алгоритм:
                - создать объект Future с реализацией call(), которая возвращает результат
                - создать объект Thread на основе Future
                - запустить поток
                - получить результат Future.get()

            поток запускается отдельный методом (не в конструкторе / статическом блоке)

            Исключения:
                задачи, которые выполняет Callable могут вызывать различные исключения
                все они оборачиваются в ExecutionException и выбрасываются из get()
                обычно делят на три типа
                    Error - пробрасываются
                    RuntimeException - возвращаются и пробрасываются
                    остальные оборачиваются в какое-будь одно

        5.5.3 Семафоры

            методы:
                asquire() - запращивает разрешение, если недоступно - блокируется
                release() - освобождает ресурс
            управляет количеством активностей, которые могут обращаться к 
                определенному ресурсу или выполнять действие
            при создании объекта Semaphore указывается количество разрешений
            бинарный семафор (с количеством = 1) - мьютекс. Тот кто получил 
                разрешение, держит его
            на основе семафоров можно строить пулы ресурсов (их же можно
                на основе блокирующих очередей)
            пример построения блокирующей ограниченной колекции на основе семафора

                public class BoundedHashSet<T> {
                    private final Set<T> set;
                    private final Semaphore sem;

                    public BoundedHashSet(int bound){
                        this.set = Collections.synchronizedSet(new HashSet<T>());
                        this.sem = new Semaphore(bound);
                    }

                    public boolean add(T o) throws InterruptedException{
                        sem.asquire();
                        boolean wasAdded = false;
                        try {
                            wasAdded = set.add(o);
                            return wasAdded;
                        } finally {
                            if (!wasAdded) // ничего не добавили, освобождаем сразу
                                sem.release();
                        }
                    }

                    public boolean remove(T o) {
                        boolean wasRemoved = set.remove(o);
                        if (wasRemoved) 
                            sem.release();
                        return wasRemoved;
                    }
                }

        5.5.4 Барьеры

            блокируют группу потоков, пока не произойдет некоторое событие 
            все потоки должны подойти к барьеру в некотовый момент времени
            защелки ожидают событий, барьеры ожидают потоки

            класс CyclicBarrier 
                фиксированное число участников встречается у барьера
                применяется в итерационных алгоритмах, когда подзадачи выполняются 
                    отдельно, а их результаты объединяются
                при достижении барьера, потоки вызывают await(), который 
                    блокирует выполнение до того, как все потоки достигнут
                    барьера
                когда все достигают - барьер сбрасывается, потоки освобождаются
                если время ожидания на await() истекло или поток, заблокированный
                    на await() прерывается возбуждается исключение BrokenBarrierException
                    на всех методах await()
                при успешном завершении await() возвращает уникальный индекс
                в конструктор можно передать действие барьера (Runnable)
                    выполнится когда барьер пройден, до освобождения потоков

                применяются в моделировании: на каждом шаге в разных потоках
                    вычисления, которые должны завершиться до перехода на следующий шаг

            пример использования для моделирования:
                вся задача разбивается на n частей
                в случае вычислительных задач, без ввода-вывода, сетевого обмена
                    n оптимально равно количеству ядер, 
                    при большем - начинается конкуренция за ресурсы процессора
                public class CellularAutomata {
                    private final Board mainBoard;
                    private final CyclicBarrier barrier;
                    private final Worker[] workers;

                    public CellularAutomata(Board board) {
                        this.mainBoard = board;
                        int count = Runtime.getRuntime().availableProcessors();
                        this.barrier = new CyclicBarrier(count,
                            new Runnable() {
                                public void run() {
                                    mainBoard.commitNewValues();
                                }});
                        this.workers = new Worker[count];
                        for (int i=0; i<count; i++) {
                            workers[i] = new Worker(board.getSubBoard(count, i));
                        }
                    }

                    private class Worker implements Runnable {
                        private final Board board;
                        public Worker(Board board) {this.board = board;}
                        public void run() {
                            while(!board.hasConverged()){
                                for (int x=0; x<board.getMaxX(); x++) {
                                    for (int y=0; y<getMaxY(); y++) {
                                        board.setNewValue(x, y, computeNewValue(x, y));
                                    }
                                }
                                try {
                                    barrier.await();
                                } catch (InterruptedException e) {return}
                                 catch (BrokenBarrierException e) {return}
                            }
                        }
                    }

                    public void start() {
                        for (int i=0; i<workers.length; i++) {
                            new Thread(workers[i]).start();
                        }
                        mainBoard.waitForConvergence();
                    }
                }        

            класс Exchanger
                двусторонний барьер, в котором стороны обмениваются данными у барьера
                полезен когда стороны выполняют асиметричные действия
                (напр. один поток заполняет буфер, другой сбрасывает, с помощью 
                    барьера полный буфер обменивается на пустой напр.)
                по сути безопасная публикация объектов





