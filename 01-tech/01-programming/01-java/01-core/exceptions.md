Исключения
    исключения как класс
    можно создавать свои
    иерархия:
                Throwable
            |               |
        Error               Exception
                        |                   |
                    IOException            RuntimeException

    Error - внутренние ошибки, нехватка ресурсов, пргораммно редко обрабатываются
    RuntimeException - ошибки, связанные с программированием

    контролируемые и неконтролируемы исключения (checked/unchecked)

Объявление исключений:
    указание на то, что в данном методе возможны исключения
    public String readLine() throws IOException  {...}
    можно несколько через зпт
    при указании суперкласса, метод может генерировать исключения-подклассы

    зачем:
        необработанное исключение - прерывает выполнение, нужно предупредить
    когда возникают:
        - вызывается метод генерирующий контролируемое (напр. readLine)
        - явно оператором throw вызывается контролируемое для показа ошибки
        - ошибки программирования - неконтролируемое (напр. выход за границу массива)
            обычно это наследники Error, RuntimeException
        - внутренние ошибки ВМ, библиотек - неконтролируемое

        в 1-м и 2-м случае должно обрабатываться

    подклассы:
        в подклассах можно только конкретизировать исключения или вообще не указывать
        если в суперклассе не объявлены - в подклассах также нельзя

Генерация:
    - выбрать подходящий стандартный класс исключения
    - создать экземпляр
    - вызвать методом throw
    напр.
        throw new IOException();
        или
        Exception e = new IOException("error");
        throw e;

Создание собственных классов исключений
    создается класс на основе Exception или его подкласса
    2 конструктора: без параметров и со строкой-сообщением (через toString())

    интерфейс(??) Throwable:
        Throwable()
        Throwable(String s)
        String getMessage()
    напр.
        class MyException extends IOException{
            public MyException(){}
            public MyException(String)
        }


Перехват исключений:
    try 
    {...}
    catch (тип_исключение e)
    { ...}

    если при выполнении кода внутри try возникает исключение - выполнение блока прерывается
    если тип исключения совпадает с типом в блоке catch - выполняется этот блок

    можно несколько:
        try
        catch (UnknownHostException e1){}
        catch (IOException e2) {}
        следить за порядком/иерархией

Повторная генерация исключений
    внутри блока catch новое исключение
    например чтобы заменить более общим
        catch (SQLException e){
            throw new ServletException("Databace error " + e.getMessage());
        }
    можно указывать причину
        Throwable se = new ServletException("Databace error");
        se.setCause(e);
        throw se;
        позже извлечь
            se.getCause();

Блок finally
    для выполнения кода независимо было исключение или нет
    try{
        // Блок 1
    }
    catch{
        // Блок 2
    }
    finally{
        // Блок 3
    }
    варианты:
        - блок try без исключений: выполняются блоки 1 и 3
        - в блоке try исключение, обрабатываемое catch - частично блок 1, блок 2 и 3
            если в блоке catch исключение - тогда частично блок 1 и 2 , блок 3
        - в блоке try необрабатываемое исключение - частично блок 1, блок 3

    итого: блок finally выполняется всегда, независимо были ли исключения и где

Рекомендации:
    - исключения не должны заменять простую проверку
        напр. вместо проверки на пустоту списка - try
        затраты на обработку исключения - уменьшение производительности

    - не увеличивать число блоков try
        не нужно каждый метод помещать в отдельный try
        совокупно решаемая задача - ее в блок try

    - использовать иерархию исключений:
        не стоит использовать Throwable, логика менее понятна в таком  случае

    - не заглушать исключения
        допустим вызывается метод, генерирующий исключения, но редко, обрабатывать - не хочется
        компилятор не пропустит, есть вариант - заглушить
            try{
                // этот метод
            }
            catch{} // пусто
        теперь компилируется, но при исключении - никакой обработки не будет

    - исключение или ?
        возвращать фиктивное значение если неверные параметры или исключение?
        напр. вернуть null если стек пуст при вызове pop(); вместо исключения
        лучше исключение на этом этапе, чем позже при обращении к null

    - не боятся передавать исключения другим обработчикам