### Thread
[tutorial](https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html)

##### Запуск
* Создать объект класса `Thread` с передачей в конструкторе объекта с интерфейсом `Runnable`
* Унаследовать класс `Thread` и переопределить метод `run`

##### Завершение процесса

Процесс завершается когда завершаются все его потоки. Можно поток объявить демоном. Тогда если все обычные потоки завершены - демоны также будут завершены принудительно

`myThread.setDaemon(true)` - назначить демоном (перед запуском)
`myThread.isDaemon()` - проверка


##### Приостановка выполнения через sleep

вызов статического метода `Thread.sleep(long millis)`
или `Thread.sleep(long millis, int nanos)` 

точное время не гарантируется
вызывает исключение `InterruptedException`, если был прерван другим потоком
можно не обрабатывать, если один поток, когда несколько ???

##### Прерывания

Поток завершается когда завершается метод `run()`
Досрочно завершить поток можно послав сигнал (прерывание). При этом поток, принявший сигнал вправе его проигнорировать.

Поток может реагировать на отправку ему прерывания двумя путями:
* если в это время выполняется метод, который генерирует `InterruptedException` (напр. `sleep()`), тогда будет сгененировано исключение
* поток может периодически проверять состояние флага `Thread.interrupted()`, при установленном - завершать работу или генерировать `InterruptedException` (для централизированного завершения)

###### Флаг статуса прерывания

`Thread.interrupt()` устанавливает этот флаг
при проверке `Thread.interrupted()` автоматически сбрасывается
метод `myThread.isInterrupted()` не сбрасывает флаг
при вызове исключения в методах типа `sleep()` флаг также сбрасывается


### Прерывание потоков

* напрямую извне остановить поток нельзя
* можно послать запрос на прекращение
* метод `interrupt()` устанавливает флаг статуса прерывания для потока
* поток во время своей работы может периодически проверять этот флаг
* можно так `Thread.currentThread().isInterrupted()` (не сбрасывает флаг)
* или так `Thread.interrupted()` (сбрасывает флаг)
* но если поток заблокирован (`sleep()` или `wait()`), тогда проверять нельзя. Для этого используется исключение `InterruptedExpection`
* иначе: методы `sleep(), wait()` при установке статуса прерывание вызывают исключение
* метод `yield()` принудительно отнимает управление у текущего потока. 

#### Примеры обработки прерывания

    // через исключение, с прекращением через возврат
    try {
        Thread.sleep(4000);
    } catch (InterruptedExpection e) {
        return;
    }

    // без прерываний, через проверку флага
    while(true){
        heavyCrunch();
        if (Thread.interrupted()) {
            return;
        }
    }

    // с выходом через генерацию прерывания
    ...
    if (Thread.interrupted()) {
        throw new InterruptedExpection();
    }


### Состояние потоков

* Созданный (new) - после создания объекта через new. Еще не запущен
* Запущенный (runnable) - после вызова `start()`. Когда на самом деле начнет выполняться решает ОС
* Блокированный (blocked), если:
    - для потока вызван `sleep()`
    - поток ожидает завершения ввода/вывода
    - поток пытается заблокировать объект, уже блокированный другим
    - поток ожидает выполнения некоторых условий (см. далее)
    Пока поток блокирован, можно другие запускать
* Остановленный (dead) - по завершению метода `run()` (нормально или не перехватом исключения)

`isAlive()` - проверяет запущен поток или нет. Если runnable или blocked вернет Истина. Различить запущен или блокирован, еще не запущен или уже остановлен нельзя.

### Свойства потоков

#### Приоритет

* каждый поток имеет приоритет от Thread.MIN_PRIPRITY (1) до Thread.MAX_PRIORITY (10)
* значение по умолчанию - Thread.NORM_PRIORITY (5)
* при создании потока, если не указать, наследует приоритет потока, из которого создается
* можно устанавливать `setPriority()`
* предполагается что планировщик ОС первыми выбирает на исполнение потоки с высоким приоритетом. Но конкретно всё зависит от ОС. (может вообще не быть приоритетов)

#### Потоки-демоны
* поток-демон предназначен для обслуживания других потоков
* сделать демоном: `setDaemon(true)` (перед запуском)
* если у процесса остаются только демоны, он завершается принудительно

#### Группы потоков
* потоки можно объединять в группы, для последующей групповой обработки (массово прервать напр.)
* группа создается `ThreadGroup group = new ThreadGroup(name);`
* затем передается в конструктор потока
* теперь напр. `interrupt`, примененный к группе, будет применен к каждому потоку группы

### API класса Thread

* `static Thread currentThread()` - получить текущий поток

* `static int activeCount()` - приблизительное количество потоков в **группе потоков**
* `long getId()`
* `String getName()` - возвращает имя. Имя может указываться в конструкторе
* `int getPriority()`

* `static void yield()` - отнимает управление у текущего потока. ОС может отдать управление другому потоку
* `void join()` - заставляет текущий поток ожидать завершение другого потока