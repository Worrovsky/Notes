Stream API

java.util.stream

    Особенности потоков:
        - не являются коллекциями
        - не сохраняют свои элементы
        - неизменяемы
        - не могут использоваться повторно
        - нет индексированного доступа к элемента

    Преимущества:
        - нет циклов
        - "что делать" вместо "как делать"
        - избавляют от null-проверок

    Два вида методов:
        - конвейерные - возвращают другой stream
        - терминальные - возвращают другой объект 
            (коллекции, примитивы, Optional и др.)

    Общее правило:
        поток может имеет несколько конвейерных методов, но только
            один терминальный в конце. Выполнение конвейерных - лениво,
            до тех пор, пока не будет вызван терминальный


    пример
        myCollection.stream()
            .filter((s) -> s.contains("1"))
            .skip(2)
            .findFirst();


    Создание потоков
        - из коллекции      collection.stream()
        - из значений       Stream.of(val1, val2, ...)
        - из массива        Arrays.stream(array)
        - из файла          Files.lines(path)           // каждая строка - элемент файла
        - через билдер      Stream.builder().add(val1).add(val2)...build()
        - бесконечные       Stream.itetate(начальное, выражение) 
                                Stream.itetate(1, n->n+1)
                            Stream.generate(выражение)
                                Stream.generate("a1")
                            для бесконечных нужно применять ограничение limit()

    Конвейерные методы
        dictinct        убирает дубли (через equals)
        filter          фильтрация по условию
        limit           ограничение выборки
        map             возвращает поток, полученный в результате применения
                            функции к каждому элементу
        peek            ??? тот же map
        skip            пропуск первых N элементов
        sorted          сортировка через стандартный порядок или через Comparator
        mapToInt, mapToLong, mapToDouble    аналог map, потоки примитиыных данных
        flatMap         может создавать несколько элементов из исходного

    Терминальные
        allMatch        true если условие выполнено для каждого элемента потока
        anyMatch        если хотя бы для обного
        noneMatch       если ни для обного элемента не выполнено условие
        collect         представляет элементы в виде коллекции
        count           возвращает кол-во элементов
        findAny         возвращает Optional, описывающий любой подходящий элемент
        findFirst       возвращает Optional, описывающий первый подходящий элемент
        forEach         применяет переданную функцию к каждому элементу (порядок не гарантируется)
        forEachOrdered  то же, что и forEach, но с сохранением порядка
        max, min        мин/макс через Comparator
        reduce          выполняет агрегирующую функцию и возвращает один результат
        toArray
        для примитивных типов
        average         среднее
        mapToObj        числовой поток в поток объектов
        sum             сумма