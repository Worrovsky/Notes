# Lombok

[tutorial](https://objectcomputing.com/resources/publications/sett/january-2010-reducing-boilerplate-code-with-project-lombok)

## 0. TODO

[baeldung](https://www.baeldung.com/intro-to-project-lombok)
подробнее про проблемы hash/equals и JPA


## 1. Установка

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version></version>
    </dependency>

## 2. Аннотации

### 2.1 @Getter и @Setter

Ставится над полями класса.

Добавляет геттеры/сеттеры для полей

Имена методов: `getXXX`, `isXXX` (для boolean), `setXXX`.

Если уже в классе есть метод с таким именем и сигнатурой (???), не будет создан

Есть опциональный параметр **AccessLevel**:

    @Setter(AccessLevel.PROTECTED) private String name;

### 2.2 @NonNull

Ставится над параметром, методом, полем.

Добавляет проверку на `null`, если значение равно `null`, вбрасываетсz NPE.

Если конструктор генерирует тоже Lombok, тогда и в конструктор добавляется проверка.

Аналогичные аннотации есть в Idea, FindBug и разных других проектах.

### 2.3 @ToString

Ставится над классом.

Добавляет метод `toString()`.

По умолчанию добавляет в вывод имя-значение для всех не статических полей.

Можно отключить вывод имен полей `includeFieldNames = false`.

Настроить поля выводимые: аннотации **@ToString.Exclude** или **@ToString.Include** (еще можно упорядочить через `rank()`).

Можно добавить вывод для суперкласса через параметр: `callSuper = true`.

### 2.4 @EqualsAndHashCode

Ставится над классом.

Добавляет `equals()` и `hashCode()`

По умолчанию включаются все не статические поля.

Можно исключать поля через **@EqualsAndHashCode.Exclude** или включать через **@EqualsAndHashCode.Include**. Можно задать, что только с явным указанием должны включаться `onlyExplicitlyIncluded = true`

Параметр `callSuper = true` - вызов `equals()` и родительского класса и включение хеша родителя в хеш текущего класса. Нельзя ставить, если класс не наследуют другие (тогда будет `equals()` от `Object`, что будет ломать логику). Lombok выдает ошибку компиляции в этом случае.







### 2.5 @Data

Как реализация POJO.

Это комбинация **@ToString**, **@EqualsAndHashCode**, **@Getter**, и **@Setter**. Также генерируется конструктор, в котором параметрами являются все **@NonNull** или `final` поля.

Параметр `staticConstructor = "of"`: по умолчанию пустой "", обычный конструктор создается. Если указать значение, конструктор будет приватным, создает статический фабричный метод вместо конструктора.

### 2.6 @Cleanup

Ставится над локальной переменной.

Назначение - обеспечить очистку ресурса (через вызов метода `close()`). 

Помещает весь код от аннотации до конца области видимости в блок `try/finally`. В части `finally` вызывается метод close().

Параметр `value` может переопределять имя вызываемого метода.

Проблема может быть если, блок `try` вызывает исключение и метод `close()` тоже вызывает исключение, то исключение из блока `try` будет скрыто последующим исключением.

Также подразумевается, что ресурс не равен `null`

### 2.7 @SneakyThrows

Разрешает вызывать проверяемые исключения, без необходимости выносить в сигнатуру или помещать в `try/catch`

Ставится над методом.

Само исключение никак не подавляется, ни во что не оборачивается. В рантайме выбрасывается как будто нет аннотации.

## 3. Разное

Есть возможность заменить аннотации Lombok на соответствующий код. В Idea есль действие **Delombok** или через `java -jar lombok.jar delombok src -d src-delomboked`. Не для всех аннотаций работает (@NonNull, @SneakyThrow)





## 4. Проблемы Lombok + Hibernate(JPA)

[проблемы Lombok + JPA](https://thorben-janssen.com/lombok-hibernate-how-to-avoid-common-pitfalls/)

Проблемы могут возникнуть если использовать аннотации для entity-классов.

**equals()** для сущностей должен сравнивать объекты только по первичному или бизнес ключу. Если хотя бы у одного объекта ключ `null`, должно возвращаться `false`.

**@EqualsAndHashCode** по умолчанию включает все нестатические поля, поэтому просто по умолчанию нельзя использовать. Можно было бы настроить только включение поля с ключом, но реализация **@equals()** Lombok'а будет возвращать `true`, если у обоих объектов ключ равен `null`. Поэтому нельзя для сущностей использовать **@EqualsAndHashCode**.

Проблемы с **@ToString**: ссылочные поля могут быть не проинициализированы (либо указана ленивая инициализации, либо какие-то варианты ассоциации). Тогда  при вызове метода `toString()` будет запрос в БД (что может сказаться на производительности или вообще исключение, если нет открытой сессии). Можно решить настройкой включаемых полей, но стоит ли усложнять код? помнить про это при добавлении новых полей.

**Итого**:

* **@EqualsAndHashCode** и соответственно **@Data** категорически нельзя
* **@ToString** лучше не стоит