## ++
### +

#### Имена компонентов и элементов

При импорте можно задать любое имя

	import MyName from "./components/Child"

Именно это имя будет значением свойства при регистрации компонента, но имя свойства может быть произвольным

	components: {
		MyComponent: MyName
	}

Теперь имя свойства должно использоваться в шаблоне. Причем допускается преобразование camelCase в дефисную нотацию

	<MyComponent/>
	<my-component/>	

#### Глобальная регистрация компонентов

Один раз регистрируем, доступен во всех других компонентах без доп. настроек

В файле `main.js`

	import Child from "...";
	Vue.component("child-component", Child);
	
	new Vue(...).$mount('#app')


#### Изоляция компонентов

Компоненты работаю в изоляции.
Напр. один компонент несколько раз использован в родительской шаблоне. Свойства каждого такого экземпляра независимы.
Или родительский компонент и дочерний имеют свойства с одинаковыми именами. Эти свойства также независимы.

#### CSS scoping

Стиль примененный к компоненту по умолчанию применяется ко всем дочерним компонентам

	<style>
		div {border: red;}
	</style>

Если не нужно применять стиль к дочерним (дочерние имеют собственный стиль) применяется атрибут **scoped**

	<style scoped>
		...
	</style>



### Props компонентов

#### Назначение

Используются для обеспечения взаимодействия между компонентами
Определяются как массив строковых имен для свойства с имененем **props**

	<script>
		export default {
			props: ["labelText", "anotherText"],
			data ...

		}
	</script>

Определенные таким образом свойства, могут использоваться везде в компоненте, напр. в текстовой интерполяции

	<label>{{labelText}}</label>

Значения таких свойств передаются только в одном направлении: от родителя к дочернему компоненту.
Изменение *prop* свойства в дочернем компоненте может быть перезаписано родителем, поэтому обычно переназначают начальное значение на *data* или *computed* свойство

#### Использование prop в родительском компоненте

Передача значений в дочерние происходит через атрибуты пользовательских html-элементов

	<my-component label-text="Hello" init-value="Alice" />

Здесь также работает преобразование верблюжей нотации в дефисную

ЗНачения prop-атрибутов это литералы, не выражения
Если нужно передать выражения - используется **v-bind**
























## Ch 17. Жизненный цикл компонентов

Компоненты имеют жизненный цикл от создания, использования и до разрушения.
Компонент может реализовать методы жизненного цикла, которые будут вызываться на определенных этапах

### Фаза создания

На этом этапе компонент создается и настраивается для использования (обрабатываются *data-* и *computed-* свойства) 

Два метода могут вызываться: **beforeCreate()** и **created()**. Первый вызывается до инициализации data-свойств (значения свойств в этом методе - `undefined`), второй - после.

В компонентах методы жизненного цикла определяются сразу в секции **script** (не внутри **methods**)

	export default {
		data: function() {
			return {
				flag: true
			}
		},
		beforeCreate() {..},
		created() {}
	}

В методе **beforeCreate()** уже существует ссылка this и ей присвоен объект. К этому объекту будут присоединяться свойства (data, computed), методы из *methods*. Но это будет позже. На этапе **beforeCreate** объект пустой. На этапе **created** уже заполнен.

Также в процессе создания выполняются мероприятия по обеспечению реактивности. Так например для каждого свойства из **data** в объект компонента добавляется свойство и геттеры/сеттеры. Таким образом, все реактивные свойства должны быть определены до создания объекта (секция script).

### Фаза монтирования

На этом этапе работа с шаблоном, data binding, директивами и т. п.

Метод жизненного цикла - **mounted()**

Внутри этого метода есть возможность доступа к DOM через переменную **$el**.
Но следует избегать такого подхода

	data: {
		...
		names: []
	},
	mounted() {
		this.$el.dataset.names.split(",").forEach(n => this.names.push(n));
	}

В примере data-свойство `names` заполняется значениями из пользовательского атрибута `data-names`, установленного в корневом теге.

### Фаза обновления

После создания и монтирования компонента. Отслеживает изменение своих свойств. При изменении вызываются **beforeUpdate()** (изменение обнаружено, но не обработано)и **updated()** (изменение обработано)

## Ch 18. Слабо связанные компоненты

Как обеспечить взаимодействие между компонентами (кроме способа через **props**)

### Внедрение зависимостей

Позволяет определять сервис (любое значение, функция, объект) и сделать его доступным любым потомкам. При этом приемник не обязан быть прямым дочерним компонентом источника, но должен быть в иерархии источника

#### Объявление сервиса

В корневом компоненте добавляем свойство **provide**. Значение как у **data** - функция, возвращающая объекты. Доступ к этому объекту будет у всех других компонентов, так как они потомки основного компонента

	export default {
		name: "App",
		provide: function() {
			return {
				colors: {
					bg: "bg-secondary",
					text: "text-white"
				}
			}
		}
	}

#### Подключение сервиса через внедрение зависимостей

Свойству **inject** компонента присваивается массив строковых имен переменных, в которые будут передаваться значения

	<input v-bind:class="[colors.bg, colors.text]" />
	...
	export default {
		inject: ["colors"]
	}

#### Переопределение сервисов

Когда Vue создает компонент со свойством **inject**, он ищет в родителях соответствующее свойство **provide** постепенно поднимаясь по иерархии. Таким образом компоненты могут переопределеть сервисы от вышестоящих компонентов

#### Реактивные сервисы

Для обеспечения реактивности в источнике создаем объект в **data** и его используем в сервисе. Теперь изменения в этом объекте будут распространяться по приложению при изменении в родителе.

Но опять же изменения от дочернего в родитель не передаются

	...
	data: function() { return {
		reactiveColors: {
			bg: ..,
			text: ...
		}
		}},
	provide: function() { return {
		colors: this.reactiveColors
		}}

#### Другие свойства сервисов

На стороне приемника можно:
* обеспечить значение по умолчанию, если сервис не определен
* поменять имя, под которым свойство сервис известен в компоненте-приемнике

Для этого значение свойства в **inject** делаем объектом.
Имя свойства - то имя под которым сервис будет известен в текущем компоненте
Значение свойства **from** - то имя под которым сервис зарегистрирован в источнике. В свойстве **default** указано значение по умолчанию (общий шаблон: `() => что-то по умолчанию`, в примере - функция)


	...
	inject: {
		format: {
			from: "labelFormatter", 
			default: () => (value) => `Default ${value}`
		}
	}


### Event Bus

Позволяет передавать сообщения между компонентами, не связанными отношением родитель-потомок



## Ch 19. 

### Выполнение запроса

Axios позволяет выполнять разные виды запросов(`get()`, `post()`) или универсальный `request()`

	<script>
		import Axios from "axios";
		let baseUrl = "http://localhost:3500/products";
		...
		created() {
			Axios.get(baseUrl).then(resp => {
					this.proccessProducts(resp.data);
				});
		}
	</script>

Запросы обычно выполняются в `created()` или `mounted()`. Выбор - за разработчиком, но последовательно в одном месте

метод `get()` возвращает Promise с объектом запроса с полями:
* status - код ответа (200 / 400 / 500) 
* statusText - текстовое представление ("Ok")
* headers - объект с заголовками
* data -  содержимое запроса, распарсенный json
* config - конфигурация запроса
* request - объект XMLHttpRequest

Можно через **acync/await**:

	acync created() {
		let data = (await Axios.get(url)).data;
		this.proccessProducts(data);
	}

### Создание отдельного сервиса для запросов

Можно выделить код, выполняющий запросы из компонента

I. Создаем файл `restDataSource.js` и в нем создаем объект, выполняющий запросы

	// restDataSource.js
	import Axios from 'axios';
	const url = "...";
	export class RestDataSource {
		async getProducts() {
			return (await Axios.get(url)).data;
		}
	}

II. Подключаем экземпляр объекта к приложению

	// main.js
	...
	import { RestDataSource } from "./restDataSource";
	...
	new Vue({
		...
		provide: function() {
			return {
				eventBus: new Vue(),
				restDataSource: new RestDataSource()
			}
		}
		}).$mount('#app')

III. Используем в компонентах

	....
	inject: ['eventBus', 'restDataSource'],
	async created() {
		this.proccessProduct(await this.restDataSource.getProducts());
	}




Ch 21.

### Асинхронные компоненты

Используется для ленивой загрузки, загрузки по требованию. Когда компонент нужен не сразу или вообще нужен не в каждом сеансе работы.

Что лучше: ленивая или ранняя загрузка? Ранняя загружает больший объем сразу, ленивая - меньше сразу, но в процессе работы выполняет доп. запросы. В общем если точно будет использоваться компонент, ленивая не нужна как правило, лучше грузить сразу.

Чтобы сделать компонент ленивым, нужно особым образом импортировать вместо обычного
	
	import UsualComponent from "./components/UsualComponent"
	const MyComponent = () => import("./components/LazyComponent");

Обычные импорты пакуются в основной пакет, динамический импорт заставляет помещать код в отдельный пакет.

#### Prefetch (предварительная загрузка)

По умолчанию проект настроен так, что браузеры могут предварительно загружать контент, который понадобится позже. Такое поведение может разрушать ленивую загрузку компонентов. Это можно отключить в настройках проекта:

	// файл vue.config.js в корне проекта
	module.export = {
		chainWebpack: config => {
			config.plugins.delete('prefetch');
		}
	}

Увидеть ленивую загрузку можно в DevTools: инициализация компонента сопровождается загрузкой js ресурса

#### Конфигурирование ленивой загрузки

 Опции конфигурации:

 * **component**  - сам компонент
 * **loading** - компонент-филер, который можно показывать на время загрузки
 * **delay** - задержка в мс, после которой начинает показываться филер (200 мс по умолчанию)
 * **error** - компонент-ошибка, если загрузка не удалась или по таймауту
 * **timeout** - собственно таймаут (бесконечно по умолчанию)

Компонент-филер сам не должен быть ленивым (есть риск, что не загрузится)

	сonst LazyComponent = () => ({
		component:  import("..."),
		loading: LoadingComponent,
		delay: 100
	})

Для тестирования можно в DevTools включить профиль с задержкой

Есть вариант сгруппировать несколько компонентов в один пакет, чтобы весь пакет грузился целиком, как только понадобится любой из них. Реализуется через комментарий в импорте

	...
	component: import( /* webpackChunkName: "advanced"*/ "./components/MyComp")



Ch 22. URL Routing

### Основы

Используется в сложных приложениях для отображения компонентов на основе url

#### Конфигурирование

`npm install vue-router`

Обычно создается файл в `src/router`

Импортируются `Vue`, `VueRouter`; импортируются компноненты

	// src/router/index.js
	import Vue from "vue";
	import VueRouter from "vue-router";
	
	import ProductDisplay from "../components/ProductDisplay";
	import ProductEdit from "../components/ProductEdit";
	
	Vue.use(VueRouter);
	
	export default new VueRouter({
		routes: [
			{path: "/", component: ProductDisplay},
			{path: "/edit", component: ProductEdit}
		]
	})




### Url Route Matching

#### Работа через фрагменты

Пути проверяются на соответствие в том порядке, в котором они объявлены при конфигурировании в **routes**. При сравнении важна только часть url после `#` - фрагмент.

	http://localhost:8080/#/edit

 Стандартно браузеры использует фрагменты для навигации по статическому содержимому, Vue использует фрагменты, т.к. они позволяют обновлять страницу без отправки запросов. 

#### Работа без фрагментов

При работе через фрагменты url может смущать пользователя. При ручном вводе обычного url (напр. `localhost:8080/edit` вместо `/#/edit`) будет переход на неизвестный адрес.
Можно настроить на работу с HTML5 History API. Новые браузеры это поддерживают, если с такой настройкой будет запущено на старом браузере - автоматически Vue переключится на фрагменты

	export default new VueRouter({
		mode: "history",
		routes: [...]
	})

**mode** принимает два значения: *hash* - по умолчанию (фрагменты), *history* - обычные адреса

#### Перехват неверных адресов

Можно настроить сервер, чтобы для адрес для которых нет содержимого, возвращался `index.js`.

Другой вариант подключить редирект (путь `*` означает любой адрес)

	export default new VueRouter({
		routes: [
			{path: "/", component: ProductDisplay},
			{path: "*", redirect: "/"}
		]
	})

#### Псевдонимы для адресов

Позволяет несколько адресов указать на один компонент

	export default new VueRouter({
		routes: [
			{path: "/", component: ProductDisplay, alias: "/list"}
		]
	})

#### Получение данных о url в компонентах

Для этого используется свойство **$route** со следующими свойствами:

* *name* - возвращает имя для именованного пути
* *path* - часть url, path (напр. `/edit/4`)
* *params* - объект с параметрами url 
* *query* - объект с значениями параметров запроса (после `?`)

Напр. так

	...
	methods: selectProduct() {
		if (this.$route.path == "/create") { ... }
	}

#### Динамические пути

Позволяет работать с url типа `/edit/6`

I. В конфигурации указываем, что url состоит из нескольких сегментов
