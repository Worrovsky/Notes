## 1. Selections

[d3-selection](https://github.com/d3/d3-selection/blob/v2.0.0/README.md#select)

`d3.select()` - выбирает первый
`d3.selectAll()` - набор

Варианты параметра в `select()`:

* `aaa` - тег с имененм `aaa`
* `.a` - элемент класса `a`
* `#a` - элемент с id `a`
* можно объединять по И: `div.t` - элемент div c классом t

Функции для работы с **selection**

`append()` - добавляет элемент
`attr()` - устанавливает атрибут
`text()` - задает текст
`style()` - задает стиль

параметрами может быть:

* ключ-значение `style('color', 'red')`
* ключ и функция (данные + индекс элемента в выборке)
    - `style('color', (d, i) => {return (i % 2 === 0)? 'red': 'blue'})`
* объект
    
Например так:

    d3.selectAll('div').style({
        'color': (d, i) => {...},
        'background-color': (d, i) => {...}
    })

## 2. Data binding

Есть некоторые данные, для них нужно построить визуализацию, отображать изменения в данных и т. п.

### data()

функция `data()` привязывает данные к выборке.

    d3.selectAll('div').data([1, 3, 5, 12])

Внутри: создается свойство `__data__` у элемента, ему присваивается значение

Если размер массива меньше размера выборки, у лишних элементов не будет создано свойство. Если массив больше, новых элементов не добавляется


### enter() и exit()

функция `data()` может работать с пустой выборкой. С помощью `enter()` создаются отсутствующие элементы

Например изначально пустой документ:

    const selector = d3.select('body')
        .selectAll('div') // пустая выборка
        .data([1, 2, 4])
        
        selector.enter() // создали заготовку для новых
            .append('div') // добавляем
            .text(d => d)

Если еще раз вызовем эту цепочку, но с массивом большего размера, добавятся новые данные. Прежние не изменятся, даже если в массиве будут другие данные

Чтобы изменить нужно вызывать обновление на селекторе

    selector.text(d => d)

Повторный вызов с массивом меньшего размера ничего не изменит. Нужно явно удалять

    const exiting = selector.exit()
    exiting.remove()

### В общем

* начинается все с выборки элементов, обычно пустой
* затем связывание с данными через `data()`
* данные переносятся в элементы. Элементы при этом не создаются пока
* в процессе данные могут переприсваиваться (другие, больше, меньше)
* если данных больше чем было, создаются новые элементы в выборке. Доступ к новым созданным элементам получается через `enter()`
* если данных меньше, лишние помечаются как удаляемые и удаляются из текущей выборки. Доступ к удаляемым через `exit()`. Это обычная выборка. Для явного удаления из документа `exit().remove()`
* При вызове `data()` данные переносятся в свойство `__data__` элемента
* При обновлении данных через `data()` нужно явно вызывать обновление элементов


## 3. Scales

### 3.1 Basic

[git docs](https://github.com/d3/d3-scale)

Задают соответствие между входными данными (**domain**) и выходными (**range**)
Есть разные виды:

* **continuous (непрерывные)** - линейные, логарифмические и т. п.
* **ordinal (порядковые)**
* другие

### 3.2 Continuous scales

Отображают непрерывное входное значение в непрерывное выходное
Есть обратная функция `invert()`


    const x = d3.scaleLinear()
        .domain([19, 199])
        .range([0, 200])

На выходе цвета
    
    const colorScale = d3.scaleLinear()
        .domain([10, 100])
        .range(['brown', 'steelblue'])

Масштабы с датами

    date = d3.scaleLinear()
        .range([new Date("2009-01-01 00:00:00"), new Date("2009-12-31 23:59:59")])

    days = d3.scaleLinear()
        .range([new Date("2009-01-01"), new Date("2009-12-31")])    

Методы:

**continuous(value)** - получение значения по входному 

    colorScale(20); // #9a3439   

**continuous.invert(value)** - обратная операция, получение входного значения по выходному. Если значение `value` не попадает в диапазон `range`, поведение зависит от настройки через метод `clamp()`

Работает только, если range - числовой, иначе возвращает `NaN`

**continuous.domain([domain])** - задает входной диапазон
Если без указания параметра - возвращает текущий domain

В качестве `domain` - массив с минимум 2-мя элементами. 

Если больше - получаем кусочную шкалу. Количество элементов в range и domain должно быть одинаковым (иначе обрежется по минимуму) и domain должен быть упорядочен

    let piecewiseScale = d3.scaleLinear()
        .domain([-1, 0, 1])
        .range(['red', 'white', 'green'])

**continuous.range([range])** - задает выходной диапазон. Тип не обязательно числовой, но нужен интерполятор (см. `interpolate()`)
Без указания параметра - возвращает текущий range

**continuous.clamp(clamp)** - определяет, что делать если нужно получить выходное значение за пределами входного диапазона domain:

    scale.clamp(true) // ограничивает в значениях range
    scale.clamp(false) // может экстраполировать за пределы выходного диапазона

По умолчанию = false
Без параметра - возвращает текущее значение

**continuous.unknown([value])** - устанавливает выходное значение для незаполненного входного (NaN. undefined, 'No Data')

**continuous.interpolate(int)** - устанавливает интерполятор, т. е. функцию, отображающую нормализированные входные данные в данные из range. 

Есть по умолчанию. Как выбирается интерполятор в зависимости от типа данных в range, см. [d3-interpolate](https://github.com/d3/d3-interpolate#interpolate)

**continuous.rangeRound([range])** - выходные значения округляются до целых


**continuous.ticks(count)** - возврашает массив входных значений заданного размера. Без указания размера - 10 шт. Значения равномерно распределены, читабельный формат, степени 10 и т. п., можно для подписи к осям использовать

**continuous.tickFormat** - что-то про форматирование

**continuous.nice()** - округление domain

## 99. Разное

### 99.1 Заметки по курсу от freeCodeCamp

#### 99.1.0

[youtube](https://www.youtube.com/watch?v=_8V5o2UHG0E&ab_channel=freeCodeCamp.org)

#### 99.1.1 Настройка осей

**Настройка представления чисел на осях** с помощью **format()**

    axisBottom(xScale).tickFormat(format('.2s'))

[калькулятор по format](http://bl.ocks.org/zanarmstrong/05c1e95bf7aa16c4768e)

Можно свою функцию написать и передать в **tickFormat()**

    const xAxisTickFormat = number => 
        format('.2s')(number).replace('G', 'B')


**Удаление лишних линий**: (например черточки на осях)

* смотрим структуру DOM
* выбираем эти элементы в выборку
* удаляем через **remove()**

Например

    ...
    call(xAxis)
        .selectAll('tick line')
        .remove()

**Добавление заголовков**

Просто добавлением текста с заданием координат

    g.append('text').text('Title').attr('y', height)

**Добавление сетки на график**

Регулируем высоту *tikcs*

    xAxis = axisBottom(xScale)
        .tickSize(-height)


**Стилизация**

С помощью css с присвоением новых классов или использования существующих

[Sunlight Style Guide](https://sunlightfoundation.com/2014/03/12/datavizguide/)